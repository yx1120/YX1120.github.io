<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Travel Log</title>
    <url>/2020/05/19/travel/</url>
    <content><![CDATA[<h3 id="what-do-you-want"><a href="#what-do-you-want" class="headerlink" title="what do you want"></a>what do you want</h3><a id="more"></a>]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk1.7 HashMap源码</title>
    <url>/2020/05/20/jdk1.7%20HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<blockquote>
<p>1.7 HashMap底层使用的是（Entry）数组+链表实现</p>
<p>线程不安全，在多个线程进行插入操作时，可能会出现死循环，数据覆盖问题</p>
<p>1.8 中HashMap底层使用的是（Node）数组+链表+红黑树实现，不会出现死循环，但仍有数据覆盖问题</p>
<p>需要线程安全的话，建议使用ConcurrentHashMap</p>
</blockquote>
<img src='https://pic.downk.cc/item/5ec486b7c2a9a83be5103d16.png'>

<a id="more"></a>

<h3 id="1）HashMap中的字段"><a href="#1）HashMap中的字段" class="headerlink" title="1）HashMap中的字段"></a>1）HashMap中的字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//默认初始容量=16，必须为2的幂</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">   <span class="comment">//映射最大容量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">   <span class="comment">//构造函数未指定负载因子时，使用的默认负载因子：0.75</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 散列表，长度始终是2的幂。</span></span><br><span class="line"><span class="comment">    * 为什么不是向HashTable使用一个素数呢？为了方便后面的扩容操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//hash表中存储的实际元素个数</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阈值 = hash表容器capacity * 负载因子loadfactor</span></span><br><span class="line"><span class="comment"> * size &gt; 阈值，就进行扩容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">int</span> threshold;</span><br><span class="line">  	<span class="comment">// 手动指定的负载因子</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">   <span class="comment">// 此字段用于使HashMap的Collection-view上的迭代器快速失败</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">   <span class="comment">// 默认阈值，可以使用上面的 threshold覆盖该值</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果值为true，则对字符串键执行备用哈希处理，以减少由于哈希码计算能力较弱而导致的冲突发生率。</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">boolean</span> useAltHashing;</span><br></pre></td></tr></table></figure>

<h3 id="2）节点类Entry"><a href="#2）节点类Entry" class="headerlink" title="2）节点类Entry"></a>2）节点类Entry</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates new entry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）构造函数"><a href="#2）构造函数" class="headerlink" title="2）构造函数"></a>2）构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的容量和负载因子初始化HashMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//参数有效判断</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">       <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 确保初始容量是2的幂，比如指定initialCapacity=12，经过这里后，capacity=16</span></span><br><span class="line">       <span class="comment">// 即：找到不小于“指定容量”的最小2次幂</span></span><br><span class="line">       <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">           capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//初始化负载因子、计算阈值</span></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">       table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">       </span><br><span class="line">       useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">               (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">       init();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定初始容量</span></span><br><span class="line"><span class="comment">    * 使用默认的负载因子0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 无参构造</span></span><br><span class="line"><span class="comment">    * 使用默认的初始容量16 和负载因子0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3）添加元素"><a href="#3）添加元素" class="headerlink" title="3）添加元素"></a>3）添加元素</h3><blockquote>
<p>总体流程：</p>
<ol>
<li>计算散列位置，判断是否有该key,如果有，则使用新值覆盖旧值</li>
<li>没有的话，进入addEntry()<ol>
<li>判断当前元素个数是否大于阈值，大于的话<ul>
<li>进行扩容resize()，2倍扩容hash表长</li>
<li>然后将元素重新映射到新表上</li>
</ul>
</li>
<li>小于当前阈值，进入createEntry()，使用头插法插入元素</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="gt-1-put-：入口"><a href="#gt-1-put-：入口" class="headerlink" title="-&gt;1 put()：入口"></a>-&gt;1 put()：入口</h4><blockquote>
<p>作用：</p>
<ul>
<li><p>如果key已经存在，则新值取代旧值。</p>
</li>
<li><p>不存在则进入addEntry()方法</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素，如果key已经存在，则新值取代旧值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="comment">// 计算插入的索引</span></span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="comment">// 在以table[i]为头结点的链表上寻找是否已经有该key,如果有，用新值替代旧值</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="comment">//返回旧值</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">//添加Entry节点</span></span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算哈希码h的在散列表(Entry&lt;K,V&gt; [] table)上的索引</span></span><br><span class="line"><span class="comment">    * 		h: key的hashCode</span></span><br><span class="line"><span class="comment">    * 		length: table的表长</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算key的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (useAltHashing) &#123;</span><br><span class="line">           <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">               <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">           &#125;</span><br><span class="line">           h = hashSeed;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">       <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">       <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">       h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">       <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-2-addEntry"><a href="#gt-2-addEntry" class="headerlink" title="-&gt;2 addEntry()"></a>-&gt;2 addEntry()</h4><blockquote>
<p>作用：</p>
<ul>
<li>判断size是否大于阈值，大于则进行扩容resize()，并重新计算key的散列位置</li>
<li>小于则进入createEntry() 使用头插法插入元素</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素操作-2</span></span><br><span class="line"><span class="comment"> * 		hash: key的hash值</span></span><br><span class="line"><span class="comment"> * 		bucketIndex:插入的散列表索引位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//如果当前元素个数 size&gt;= 阈值 ，同时插入的位置已经有元素了---&gt;扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            <span class="comment">//扩容操作，2倍扩容。扩的是散列表的长度</span></span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            <span class="comment">//重新计算key的hash值</span></span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//重新计算散列位置</span></span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//最终的插入操作</span></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-3-resize-：扩容操作"><a href="#gt-3-resize-：扩容操作" class="headerlink" title="-&gt;3 resize()：扩容操作"></a>-&gt;3 resize()：扩容操作</h4><blockquote>
<p>作用：</p>
<ul>
<li>创建一个新的hash表（Entry数组），进入<code>transfer()</code>，将原来的hash表中元素散列到新hash表</li>
<li>重新计算阈值</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容操作：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    	<span class="comment">// 如果老散列表长度已经=HashMap最大容量【2^30】</span></span><br><span class="line">    	<span class="comment">// --&gt;修改阈值为Integer的最大值【2^31-1】，不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// 根据新散列表长创建一个新的散列表</span></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;</span><br><span class="line">    	<span class="comment">//数据转移到新表上</span></span><br><span class="line">        transfer(newTable, rehash);</span><br><span class="line">        table = newTable;</span><br><span class="line">    	<span class="comment">//计算新阈值</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前表中元素散列到新表上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="comment">//e：每一个链表头</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                <span class="comment">// 先保留头结点下一元素</span></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">               	<span class="comment">// 计算新的散列位置</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                <span class="comment">// 取旧表的表头使用头插法再次插入新表</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-4-createEntry-：最终的插入操作"><a href="#gt-4-createEntry-：最终的插入操作" class="headerlink" title="-&gt;4 createEntry()：最终的插入操作"></a>-&gt;4 createEntry()：最终的插入操作</h4><blockquote>
<p>作用：</p>
<ul>
<li>使用头插法插入元素</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//采用的是头插法，</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//先保留老头结点，后面会连上</span></span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="4）获取元素"><a href="#4）获取元素" class="headerlink" title="4）获取元素"></a>4）获取元素</h3><h4 id="gt-1-get-：入口"><a href="#gt-1-get-：入口" class="headerlink" title="-&gt;1 get()：入口"></a>-&gt;1 get()：入口</h4><blockquote>
<p>作用：</p>
<ul>
<li>如果键为空，则返回空键对应的值或null</li>
<li>不为空，进入getEntry()</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="–-gt-getEntry-：获取key对应的Entry节点"><a href="#–-gt-getEntry-：获取key对应的Entry节点" class="headerlink" title="–&gt; getEntry()：获取key对应的Entry节点"></a>–&gt; getEntry()：获取key对应的Entry节点</h4><blockquote>
<p>作用：</p>
<ul>
<li>根据key计算散列索引，然后判断该索引对应的链表是否含有key</li>
<li>有则返回key对应的节点，无返回null</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>二分搜索树</title>
    <url>/2020/05/20/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h4 id="一、特点"><a href="#一、特点" class="headerlink" title="一、特点"></a>一、特点</h4><ol>
<li>二分搜索树是一颗二叉树</li>
<li>二分搜素树的每一个节点的值都大于其左子树所有节点的值，小于右子树所有节点的值<img src="https://img-blog.csdnimg.cn/20200421172624493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<a id="more"></a>

<h4 id="二、底层维护"><a href="#二、底层维护" class="headerlink" title="二、底层维护"></a>二、底层维护</h4><ul>
<li><p>root ：树根节点</p>
</li>
<li><p>size ：树中元素个数</p>
</li>
</ul>
<h4 id="三、注意"><a href="#三、注意" class="headerlink" title="三、注意"></a>三、注意</h4><p>树中的节点必须具有可比较性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分搜索树：</span></span><br><span class="line"><span class="comment"> * 特点：1.每一个节点都比左孩子大，比右孩子小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-04-20 15:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root; <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;  <span class="comment">//元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//...具体操作在下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、搜索二叉树的基本操作"><a href="#四、搜索二叉树的基本操作" class="headerlink" title="四、搜索二叉树的基本操作"></a>四、搜索二叉树的基本操作</h4><ol>
<li>向以node为根节点的树中添加元素e，并返回根节点。【递归算法】</li>
</ol>
<blockquote>
<p>注：（除node为null外）元素e最后会和树中一个叶子节点的（左或右）孩子进行比较。叶子节点左右孩子都为空，进入比较后会返回一个的新节点，就是叶子节点的孩子。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           size++;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">       &#125;</span><br><span class="line">   	<span class="comment">//e&lt;当前节点，进入左子树继续比较。把node当做叶子节点</span></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//插入后node.left 可能会改变，需要重新接受</span></span><br><span class="line">           node.left = add(node.left, e);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//e&gt;当前节点，进入右子树</span></span><br><span class="line">           node.right = add(node.right, e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//不处理相同的情况</span></span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看以node为根节点的二分搜索树是否包含元素e</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> contains(node.left, e);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> contains(node.right, e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>前序遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.print(<span class="string">"#-&gt;"</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.print(node.e + <span class="string">"-&gt;"</span>);</span><br><span class="line">       preOrder(node.left);</span><br><span class="line">       preOrder(node.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>非递归前序遍历【<strong>借助栈</strong></li>
</ol>
<blockquote>
<p>先把根节点压入栈，【1.然后出栈访问。2. 再把左右孩子（非空）压入栈。–&gt;递归进入第一步】</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助栈实现前序非递归遍历</span></span><br><span class="line">   <span class="comment">//深度优先遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder22</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="comment">//1.把根节点压入栈</span></span><br><span class="line">       stack.push(root);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           Node pop = stack.pop();</span><br><span class="line">           System.out.print(pop.e + <span class="string">"-&gt;"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//压入左右孩子，因为使用的是栈。所以先压入右孩子，再压左孩子</span></span><br><span class="line">           <span class="comment">//那么左孩子就先出栈</span></span><br><span class="line">           <span class="keyword">if</span> (pop.right != <span class="keyword">null</span>)</span><br><span class="line">               stack.push(pop.right);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (pop.left != <span class="keyword">null</span>)</span><br><span class="line">               stack.push(pop.left);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>后序遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tailOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.print(<span class="string">"#-&gt;"</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       tailOrder(node.left);</span><br><span class="line">       tailOrder(node.right);</span><br><span class="line">       System.out.print(node.e + <span class="string">"-&gt;"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>中序遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">middleOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.print(<span class="string">"#-&gt;"</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       middleOrder(node.left);</span><br><span class="line">       System.out.print(node.e + <span class="string">"-&gt;"</span>);</span><br><span class="line">       middleOrder(node.right);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>层次遍历【<strong>借助队列</strong></li>
</ol>
<blockquote>
<p>先把根节点入队，【1.出队访问，2.再把左右孩子入队—&gt;递归-&gt;1】</p>
<p><img src="https://img-blog.csdnimg.cn/20200421172701545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层次遍历，借助队列</span></span><br><span class="line">   <span class="comment">//也叫做广度优先遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       <span class="comment">//1.把根节点压入栈</span></span><br><span class="line">       queue.add(root);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//输出这一层（栈内）所有节点</span></span><br><span class="line">       <span class="comment">//同时把这一层的所有节点的子孩子压入栈</span></span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">           Node pop = queue.remove();</span><br><span class="line">           System.out.print(pop.e + <span class="string">"-&gt;"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (pop.left != <span class="keyword">null</span>)</span><br><span class="line">               queue.add(pop.left);</span><br><span class="line">           <span class="keyword">if</span> (pop.right != <span class="keyword">null</span>)</span><br><span class="line">               queue.add(pop.right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>获取二分搜索树的最大最小值节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最小节点</span></span><br><span class="line"><span class="comment">//不断往左子树找，最后没有左子树的那个节点，就是最小节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">miniNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> miniNode(node.left);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大节点：同理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maxNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node.right == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       <span class="keyword">return</span> maxNode(node.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ol start="8">
<li>删除二分搜索树最小值，最大值的节点</li>
</ol>
<blockquote>
<ul>
<li>删除最小值节点：【不断往左子树寻找<ul>
<li>node.left = null ，找到最小节点   </li>
<li>该节点的右子树不一定为空，所以将右子树第一个节点返回作为新的根节点</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200505162228303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<blockquote>
<ul>
<li>同理：删除最大值节点：【不断往右子树寻找<ul>
<li>node.right = null , 即为最大值节点</li>
<li>该节点左子树不一定为空，所以将左子树第一个节点返回作为根节点</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// node.left==null 即：如果该节点为最小节点</span></span><br><span class="line">       <span class="comment">// 则返回该节点右子树的第一个节点</span></span><br><span class="line">       <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果左子树为空，则该节点右子树第一个为最大的节点</span></span><br><span class="line">           Node retNode = node.right;</span><br><span class="line">           <span class="comment">//断开与右子树的关系</span></span><br><span class="line">           node.right = <span class="keyword">null</span>;</span><br><span class="line">           size--;</span><br><span class="line">           <span class="comment">//返回新根节点</span></span><br><span class="line">           <span class="keyword">return</span> retNode;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//该节点不是最小节点，继续进入左子树。</span></span><br><span class="line">       <span class="comment">//用node.left 接收删除后的新根节点--&gt;A.left = C</span></span><br><span class="line">       node.left = removeMin(node.left);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回删除节点后新的二分搜索树的根</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// node.right==null    即：当前节点为最大节点</span></span><br><span class="line">       <span class="comment">// 返回左子树第一个节点</span></span><br><span class="line">       <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果右子树为空，则左子树第一个为最大的节点</span></span><br><span class="line">           Node retNode = node.left;</span><br><span class="line">           <span class="comment">//断开与左子树的关系</span></span><br><span class="line">           node.left = <span class="keyword">null</span>;</span><br><span class="line">           size--;</span><br><span class="line">           <span class="comment">//返回新根节点</span></span><br><span class="line">           <span class="keyword">return</span> retNode;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//当前节点不是最大节点,继续进入右子树寻找</span></span><br><span class="line">       node.right = removeMax(node.right);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>删除以node为根的二分搜索树中值为e的节点，并返回删除后的根节点。【递归算法</li>
</ol>
<blockquote>
<p>“待删除节点”有3种情况：</p>
<ul>
<li>左子树为空  =&gt;【删除最小节点</li>
<li>右子树为空  =&gt;【删除最大节点</li>
<li>左右子树都不为空【==如下图，删除d节点==<ul>
<li>1 .找到待删除节点 <strong>d</strong> 的右子树的最小节点 <strong>s</strong></li>
<li>2 .用 <strong>s</strong> 替代 <strong>d</strong> 的位置<ul>
<li><strong>s</strong> = miniNode(<strong>d</strong>.right);</li>
<li><strong>s</strong>.right = removeMini(<strong>d</strong>.right);</li>
<li><strong>s</strong>.left = <strong>d</strong>.left</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注：删除节点后依然维持着二分搜索树的性质</p>
<p><img src="https://img-blog.csdnimg.cn/20200505162146245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除值为e的节点，返回新的根节点 	</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//e&lt;当前节点，进入左子树</span></span><br><span class="line">           node.left = remove(node.left, e);</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//e&gt;当前节点，进入右子树</span></span><br><span class="line">           node.right = remove(node.right, e);</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//找到待删除节点e</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment">//待删除节点左子树为空</span></span><br><span class="line">           <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">               Node rightNode = node.right;</span><br><span class="line">               <span class="comment">//断开node和右子树的连接</span></span><br><span class="line">               node.right = <span class="keyword">null</span>;</span><br><span class="line">               size--;</span><br><span class="line">               <span class="comment">//返回删除节点后的（局部）根节点</span></span><br><span class="line">               <span class="keyword">return</span> rightNode;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//待删除节点右子树为空</span></span><br><span class="line">           <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">               Node leftNode = node.left;</span><br><span class="line">               <span class="comment">//断开node和右子树的连接</span></span><br><span class="line">               node.left = <span class="keyword">null</span>;</span><br><span class="line">               size--;</span><br><span class="line">               <span class="comment">//返回删除节点后的（局部）根节点</span></span><br><span class="line">               <span class="keyword">return</span> leftNode;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//待删除节点的左右子树均不为空</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//1.寻找“待删除节点”右子树的最小节点</span></span><br><span class="line">           Node rightMiniNode = miniNode(node.right);</span><br><span class="line">           <span class="comment">//2.删除待删节点的右子树的最小值并把新树的作为 “替代节点” 的右子树</span></span><br><span class="line">           rightMiniNode.right = removeMin(node.right);</span><br><span class="line">           <span class="comment">//3.把待删除节点的左子树接到 “替代节点”的左子树</span></span><br><span class="line">           rightMiniNode.left = node.left;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.将删除的节点断开联系</span></span><br><span class="line">           node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">return</span> rightMiniNode;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Java-JUC编程（1）</title>
    <url>/2020/05/21/Java-JUC%E7%BC%96%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h3><h4 id="1）区别"><a href="#1）区别" class="headerlink" title="1）区别"></a>1）区别</h4><ul>
<li>进程是程序的一次执行过程，操作系统分配资源给进程。</li>
<li>一个进程包含一个或多个线程，这些线程共享进程分配的资源</li>
<li>线程是任务调度和执行的基本单位 </li>
</ul>
<a id="more"></a>

<h4 id="2）并发与并行"><a href="#2）并发与并行" class="headerlink" title="2）并发与并行"></a>2）并发与并行</h4><ul>
<li>并发：5个人只有一把斧头，轮流砍一棵树</li>
<li>并行：5个人有五把斧头，一起砍一棵树</li>
</ul>
<h3 id="二、Synchronized和Lock的区别"><a href="#二、Synchronized和Lock的区别" class="headerlink" title="二、Synchronized和Lock的区别"></a>二、Synchronized和Lock的区别</h3><ol>
<li><p>synchronized是一个java关键字，Lock是juc包下的一个类</p>
</li>
<li><p>synchronized加锁解锁是一个自动的过程，Lock需要自己手动加锁解锁。</p>
</li>
<li><p>synchronized一个非公平锁，Lock可以手动指定。构造函数传参即可</p>
</li>
<li><p>synchronized适合锁少量的同步代码，Lock适合锁大量的同步代码</p>
</li>
<li><p>Synchronized 线程1获得锁–&gt;线程2等待，线程1阻塞–&gt;线程2一直等待）；Lock锁就不一定会等待下去；</p>
</li>
</ol>
<h3 id="三、消费者-生产者问题"><a href="#三、消费者-生产者问题" class="headerlink" title="三、消费者-生产者问题"></a>三、消费者-生产者问题</h3><h4 id="1）synchronized版–虚假唤醒"><a href="#1）synchronized版–虚假唤醒" class="headerlink" title="1）synchronized版–虚假唤醒"></a>1）synchronized版–虚假唤醒</h4><blockquote>
<p>出现的原因：存在多个消费者，生产者时。使用<code>if</code>判断等待条件</p>
<p>解决：把<code>if</code>改为<code>while</code>判断即可。当有多个生产者被唤醒时需要重新判断是否等待</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized版--生产者、消费者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  num=0</span></span><br><span class="line"><span class="comment"> *  生产者+1</span></span><br><span class="line"><span class="comment"> *  消费者-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  解决：使用while()判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区为1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// A1+1-&gt;OK   A2+1--&gt;wait()释放锁，A3+1--&gt;wait()释放锁  --&gt;此时A2,A3都挂data的等待队列上</span></span><br><span class="line">            <span class="comment">// C1-1-&gt;OK   --&gt;notifyAll()  --&gt;A2,A3都醒了。此时如果使用的是if判断，A2,A3会直接跳出if,去执行num++</span></span><br><span class="line">            <span class="comment">// 就造成了num=2的情况</span></span><br><span class="line">            <span class="comment">// 使用while()判断就会重新判断等待条件</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;"</span>+num);</span><br><span class="line">        <span class="comment">//唤醒</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;"</span>+num);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Data res = <span class="keyword">new</span> Data();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.put();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.put();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.pop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出现了很多&gt;1的情况</span></span><br><span class="line">A---&gt;<span class="number">1</span></span><br><span class="line">B---&gt;<span class="number">0</span></span><br><span class="line">C---&gt;<span class="number">1</span></span><br><span class="line">B---&gt;<span class="number">2</span></span><br><span class="line">...</span><br><span class="line">B---&gt;<span class="number">0</span></span><br><span class="line">C---&gt;<span class="number">1</span></span><br><span class="line">A---&gt;<span class="number">2</span></span><br><span class="line">C---&gt;<span class="number">3</span></span><br><span class="line">A---&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="3）Lock版"><a href="#3）Lock版" class="headerlink" title="3）Lock版"></a>3）Lock版</h4><blockquote>
<p>写法不同，使用的是while判断。不会出现虚假唤醒</p>
<p>但是执行的顺序不是有序的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lock锁版--生产者、消费者</span></span><br><span class="line"><span class="comment"> *    num=0</span></span><br><span class="line"><span class="comment"> *    生产者+1</span></span><br><span class="line"><span class="comment"> *    消费者-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// A+1-&gt;OK   A+1--&gt;wait()释放锁，B+1--&gt;wait()释放锁  --&gt;此时A,B都挂data的等待队列上</span></span><br><span class="line">                <span class="comment">// C-1-&gt;OK   --&gt;notifyAll()  --&gt;A,B都醒了。此时如果使用的是if判断，A,B会直接跳出if,去执行num++</span></span><br><span class="line">                <span class="comment">// 就造成了num=2的情况</span></span><br><span class="line">                <span class="comment">// 使用while()判断就会重新判断等待条件</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + num);</span><br><span class="line">            <span class="comment">//唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + num);</span><br><span class="line">            <span class="comment">//唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Data3 res = <span class="keyword">new</span> Data3();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.put();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.put();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.pop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.pop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A---&gt;<span class="number">1</span></span><br><span class="line">C---&gt;<span class="number">0</span></span><br><span class="line">A---&gt;<span class="number">1</span></span><br><span class="line">D---&gt;<span class="number">0</span></span><br><span class="line">...</span><br><span class="line">C---&gt;<span class="number">0</span></span><br><span class="line">B---&gt;<span class="number">1</span></span><br><span class="line">C---&gt;<span class="number">0</span></span><br><span class="line">B---&gt;<span class="number">1</span></span><br><span class="line">C---&gt;<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="4）Condition实现精准通知唤醒"><a href="#4）Condition实现精准通知唤醒" class="headerlink" title="4）Condition实现精准通知唤醒"></a>4）Condition实现精准通知唤醒</h4><blockquote>
<p>可以实现线程有序的执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.xu.multithread.kuangshen.juc.pc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 利用Lock、Condition实现精准通知</span></span><br><span class="line"><span class="comment"> * 线程交替</span></span><br><span class="line"><span class="comment"> *  标志位：num</span></span><br><span class="line"><span class="comment"> *  num=1--&gt;A执行 --&gt;通知B</span></span><br><span class="line"><span class="comment"> *  num=2--&gt;B执行 --&gt;通知C</span></span><br><span class="line"><span class="comment"> *  num=3--&gt;C执行 --&gt;通知A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-19 12:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// num!=1 --&gt;进入condition1的等待队列</span></span><br><span class="line">            <span class="keyword">while</span> (num!=<span class="number">1</span>)&#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;AAA"</span>);</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 调整num,并唤醒condition2等待队列中的一个线程</span></span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num!=<span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;BBB"</span>);</span><br><span class="line">            num = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num!=<span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;CCC\n"</span>);</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC4</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Data4 res = <span class="keyword">new</span> Data4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">               res.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">               res.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">               res.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、8锁现象理解synchronized锁"><a href="#四、8锁现象理解synchronized锁" class="headerlink" title="四、8锁现象理解synchronized锁"></a>四、8锁现象理解synchronized锁</h3><p>先总结一下</p>
<ol>
<li>synchronized 锁的对象是方法的调用者！谁先获得锁，谁先执行</li>
<li>当一个线程访问一个A类的同步方法，其他线程可以访问A类的普通方法</li>
<li>静态同步方法锁的是Class对象，所有该类对象共享这一把锁</li>
<li>静态同步方法锁的是Class,普通同步方法锁的是调用该方法的对象。使用的是不同锁，不影响</li>
</ol>
<p>再看代码：</p>
<p>第二种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、 增加了一个普通方法后！先执行发短信还是Hello？ 普通方法</span></span><br><span class="line"><span class="comment"> * 4、 两个对象，两个同步方法， 发短信还是 打电话？ // 打电话</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：当一个线程访问一个A类的同步方法，其他线程可以访问A类的普通方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个对象，两个调用者，两把锁！</span></span><br><span class="line">        Phone2 phone1 = <span class="keyword">new</span> Phone2();</span><br><span class="line">        Phone2 phone2 = <span class="keyword">new</span> Phone2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁的存在</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// hello()未使用synchronized修饰，</span></span><br><span class="line">            <span class="comment">// 当一个线程访问一个A类的同步方法，其他线程可以访问A类的普通方法</span></span><br><span class="line">            <span class="comment">//phone1.hello();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用的是不同的锁，互不影响</span></span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized 锁的对象是方法的调用者！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里没有锁！不是同步方法，不受锁的影响</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、1个静态的同步方法，1个普通的同步方法 ，一个对象，先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> * 2、1个静态的同步方法，1个普通的同步方法 ，两个对象，先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：静态同步方法锁的是Class,普通同步方法锁的是调用该方法的对象。使用的是不同锁，不影响</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个对象的Class类模板只有一个，static，锁的是Class</span></span><br><span class="line">        Phone4 phone1 = <span class="keyword">new</span> Phone4();</span><br><span class="line">        Phone4 phone2 = <span class="keyword">new</span> Phone4();</span><br><span class="line">        <span class="comment">//锁的存在</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// sendSms()：静态同步方法 Class锁</span></span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 普通同步方法，使用的是phone1锁。所以先打电话--&gt;发短信</span></span><br><span class="line">            <span class="comment">// sendSms()：静态同步方法 Class锁 该方法休眠4s不影响call()的执行，因为使用的不是同一把锁</span></span><br><span class="line">            <span class="comment">// phone1.call();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不是一把锁，不影响</span></span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Phone3唯一的一个 Class 对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone4</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的同步方法 锁的是 Class 类模板</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通的同步方法  锁的调用者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、线程安全的集合、映射"><a href="#五、线程安全的集合、映射" class="headerlink" title="五、线程安全的集合、映射"></a>五、线程安全的集合、映射</h3><p>先总结：</p>
<ol>
<li>可以使用集合的工具类Collections中的方法使之安全。比如</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collectoins.synchronizedList(list)</span><br><span class="line">Collections.synchronizedSet(set);</span><br><span class="line">Collections.synchronizedMap(map);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>Juc</code>包下的安全类。比如</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CopyOnWriteArrayList</span><br><span class="line">ConcurrentHashSet</span><br><span class="line">ConcurrentHashMap</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>为啥不推荐使用Vector【jdk1.0<ol>
<li>Vector使用的是synchronized的同步方法，效率更低</li>
<li>CopyOnWriteArrayList使用的是lock锁。【锁的粒度小，可控</li>
</ol>
</li>
</ol>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//报：java.util.ConcurrentModificationException</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//List list = new Vector(); // jdk1.0</span></span><br><span class="line">        <span class="comment">//List&lt;String&gt; list = new ArrayList&lt;&gt;();  //jdk1.2</span></span><br><span class="line">        <span class="comment">//List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line"></span><br><span class="line">        List list2 = <span class="keyword">new</span> Vector();</span><br><span class="line">        list2.add(<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                list.add(String.valueOf(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//不安全的set</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何安全-----&gt;Collections工具类和Juc包下</span></span><br><span class="line">        Set&lt;String&gt; safeSet = Collections.synchronizedSet(set);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JUC  ConcurrentHashSet</span></span><br><span class="line">        Set&lt;String&gt; safeSet2 = <span class="keyword">new</span> ConcurrentHashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不安全的map</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//安全的map</span></span><br><span class="line">        Map&lt;String, String&gt; safeMap = Collections.synchronizedMap(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JUC ConcurrentHashMap</span></span><br><span class="line">        Map&lt;String,String&gt; safeMap2 = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、Callable执行流程"><a href="#六、Callable执行流程" class="headerlink" title="六、Callable执行流程"></a>六、Callable执行流程</h3><p>先看下几个类之间的关系吧</p>
<blockquote>
<ol>
<li>Runnable和Callable接口都是一个函数式接口</li>
<li>FutrueTask 间接实现了Runnable接口。所以Thread构造函数可以接受FutureTask来开启线程</li>
<li>从图中可以看出FutrueTask 可以接受一个Callable</li>
</ol>
<p>注：Callable接口的泛型是线程体的<strong>返回类型</strong></p>
</blockquote>
<p><img src="img%5CRunnable.png" alt="Runnable"></p>
<p>如何使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call()执行了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1998</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(thread);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(task,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回值在task里面----该方法可能产生阻塞（一直等待结果</span></span><br><span class="line">        Integer ret = task.get();</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、常用辅助类"><a href="#七、常用辅助类" class="headerlink" title="七、常用辅助类"></a>七、常用辅助类</h3><h4 id="1）CountDownLatch"><a href="#1）CountDownLatch" class="headerlink" title="1）CountDownLatch"></a>1）CountDownLatch</h4><blockquote>
<p>减法计数器</p>
<p>举例：5个人吃完饭，才收拾桌子</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.xu.multithread.kuangshen.juc.add;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 减法计数器</span></span><br><span class="line"><span class="comment"> * 举例：5个人吃完饭，才收拾桌子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-21 14:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总数5</span></span><br><span class="line">        CountDownLatch downLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"吃完了..."</span>);</span><br><span class="line">                <span class="comment">// 计数器-1</span></span><br><span class="line">                downLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待5个线程结束</span></span><br><span class="line">        downLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"收拾桌子..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）CyclicBarrier"><a href="#2）CyclicBarrier" class="headerlink" title="2）CyclicBarrier"></a>2）CyclicBarrier</h4><blockquote>
<p>加法计数器</p>
<p>举例：集齐7颗龙珠，才能召唤神龙</p>
<p>说明：使用7条线程集齐龙珠，只有7条线程都执行后，才能执行“召唤神龙”线程（CyclicBarrier</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCyclicBarrier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数--传入计数的值，和一个线程体Runnable接口</span></span><br><span class="line">        <span class="comment">// 如果是8的话进入一直等待状态</span></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"召唤神龙成功！！"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"集齐了第"</span>+temp+<span class="string">"号龙珠"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用barrier进入阻塞,直到最后才执行CyclicBarrier</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>集齐了第<span class="number">1</span>号龙珠</span><br><span class="line">Thread-<span class="number">4</span>集齐了第<span class="number">5</span>号龙珠</span><br><span class="line">Thread-<span class="number">3</span>集齐了第<span class="number">4</span>号龙珠</span><br><span class="line">Thread-<span class="number">1</span>集齐了第<span class="number">2</span>号龙珠</span><br><span class="line">Thread-<span class="number">2</span>集齐了第<span class="number">3</span>号龙珠</span><br><span class="line">Thread-<span class="number">5</span>集齐了第<span class="number">6</span>号龙珠</span><br><span class="line">Thread-<span class="number">6</span>集齐了第<span class="number">7</span>号龙珠</span><br><span class="line">召唤神龙成功！！</span><br></pre></td></tr></table></figure>

<h4 id="3）Semaphore：信号量"><a href="#3）Semaphore：信号量" class="headerlink" title="3）Semaphore：信号量"></a>3）Semaphore：信号量</h4><blockquote>
<p>信号量</p>
<p>解决问题：多个共享资源的互斥</p>
<p>举例：抢车位，6辆车，只有3个车位</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数：共享的资源数    【停留的线程数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">// 获取资源，没有则等待</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"抢到了车位"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;离开了车位"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放资源，通知唤醒</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>抢到了车位</span><br><span class="line">Thread-<span class="number">2</span>抢到了车位</span><br><span class="line">Thread-<span class="number">1</span>抢到了车位</span><br><span class="line">Thread-<span class="number">1</span>--&gt;离开了车位</span><br><span class="line">Thread-<span class="number">0</span>--&gt;离开了车位</span><br><span class="line">Thread-<span class="number">2</span>--&gt;离开了车位</span><br><span class="line">Thread-<span class="number">4</span>抢到了车位</span><br><span class="line">Thread-<span class="number">3</span>抢到了车位</span><br><span class="line">Thread-<span class="number">5</span>抢到了车位</span><br><span class="line">Thread-<span class="number">4</span>--&gt;离开了车位</span><br><span class="line">Thread-<span class="number">3</span>--&gt;离开了车位</span><br><span class="line">Thread-<span class="number">5</span>--&gt;离开了车位</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-多线程基础</title>
    <url>/2020/05/21/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="一、线程的创建方式"><a href="#一、线程的创建方式" class="headerlink" title="一、线程的创建方式"></a>一、线程的创建方式</h3><p>1）继承<code>Thread</code>类</p>
<p>2）实现<code>Runnable</code>接口</p>
<p>3）实现<code>Callable</code>接口</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread-1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread-2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现Callable接口方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread-3"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCreate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1()).start();</span><br><span class="line">        <span class="keyword">new</span> MyThread2().start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实现Callable接口</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread3());</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程的返回值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer i = task.get();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、线程的状态"><a href="#二、线程的状态" class="headerlink" title="二、线程的状态"></a>二、线程的状态</h3><h4 id="1）状态转换图"><a href="#1）状态转换图" class="headerlink" title="1）状态转换图"></a>1）状态转换图</h4><p>线程有5个状态：新建、就绪、运行、阻塞、终止<br><img src="https://img-blog.csdnimg.cn/20200517161814690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2）常见方法"><a href="#2）常见方法" class="headerlink" title="2）常见方法"></a>2）常见方法</h4><table>
<thead>
<tr>
<th></th>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>静态方法</strong></td>
<td>Thread.sleep(int time)</td>
<td>使当前线程进入休眠，不会放对象锁</td>
</tr>
<tr>
<td><strong>静态方法</strong></td>
<td>Thread.yield()</td>
<td>使当前线程让出CPU—&gt;进入就绪态</td>
</tr>
<tr>
<td>实例方法</td>
<td>t1.join()</td>
<td>类似插队，其他线程需要等待t1结束后，才能继续</td>
</tr>
<tr>
<td>实例方法</td>
<td>t1.get/setPriority(int n)</td>
<td>用于获取当前和设置线程的优先级</td>
</tr>
<tr>
<td>实例方法</td>
<td>t1.getState()</td>
<td>获取线程状态</td>
</tr>
<tr>
<td>实例方法</td>
<td>t1.setDaemon(true)</td>
<td>设置当前为守护线程</td>
</tr>
</tbody></table>
<h3 id="三、线程同步"><a href="#三、线程同步" class="headerlink" title="三、线程同步"></a>三、线程同步</h3><h4 id="1）同步方法"><a href="#1）同步方法" class="headerlink" title="1）同步方法"></a>1）同步方法</h4><ol>
<li>使用<code>synchronized</code>关键字，它包括两种用法：synchronized 方法和synchronized块.</li>
</ol>
<p>同步方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> method（）&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>同步方法锁的是对象本身<code>this</code></p>
</li>
<li><p>缺陷：若将一个大的方法申明为<code>synchronized</code>将会影响效率</p>
</li>
</ol>
<h4 id="2）同步代码块"><a href="#2）同步代码块" class="headerlink" title="2）同步代码块"></a>2）同步代码块</h4><ol>
<li><p>同步块：<code>synchronized（obj）{}</code></p>
</li>
<li><p><strong><code>obj</code> 称之为同步监视器</strong></p>
<ul>
<li>obj可以是任何对象，但是推荐使用共享资源作为同步监视器</li>
<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class</li>
</ul>
</li>
<li><p>同步监视器的执行过程</p>
<ul>
<li>第一个线程访问，锁定同步监视器，执行其中代码.</li>
<li>第二个线程访问，发现同步监视器被锁定，无法访问.</li>
<li>第一个线程访问完毕，解锁同步监视器.</li>
<li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问</li>
</ul>
</li>
</ol>
<p>示例：银行取钱</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2夫妻同时到银行取钱</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步块：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-16 21:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//账户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> money; <span class="comment">//余额</span></span><br><span class="line">    String name; <span class="comment">//卡名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//银行：模拟取款</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Darwing</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Account account;</span><br><span class="line">    <span class="comment">//取了多少钱</span></span><br><span class="line">    <span class="keyword">int</span> drawMoney;</span><br><span class="line">    <span class="comment">//手里多少钱</span></span><br><span class="line">    <span class="keyword">int</span> nowMoney;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Darwing</span><span class="params">(String name, Account account, <span class="keyword">int</span> drawMoney)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawMoney = drawMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized方法：默认锁的是this。这里如果锁run()方法的话，锁的对象就是Drawing对象，相当于锁住银行了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       takeMoney();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 锁的对象是变化的量，需要增删改的量</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account)&#123;</span><br><span class="line">            <span class="comment">//余额不足</span></span><br><span class="line">            <span class="keyword">if</span>(account.money&lt;drawMoney)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName()+<span class="string">"余额不足..."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//将2个线程都堵在这里，放大问题</span></span><br><span class="line">                <span class="comment">// you,girlFriend线程都发现有100,但是钱被girl取了，变为0</span></span><br><span class="line">                <span class="comment">// 当you醒过来以为还有100，就也取了50</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取钱</span></span><br><span class="line">            account.money -= drawMoney;</span><br><span class="line">            nowMoney += drawMoney;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">"取了："</span>+drawMoney);</span><br><span class="line">            System.out.println(account.name+<span class="string">"余额有："</span>+account.money);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">"手里有："</span>+nowMoney+<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="number">100</span>, <span class="string">"结婚基金"</span>);</span><br><span class="line"></span><br><span class="line">        Darwing you = <span class="keyword">new</span> Darwing(<span class="string">"you"</span>,account,<span class="number">50</span>);</span><br><span class="line">        Darwing girl = <span class="keyword">new</span> Darwing(<span class="string">"girl"</span>,account,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        you.start();</span><br><span class="line">        girl.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）死锁"><a href="#3）死锁" class="headerlink" title="3）死锁"></a>3）死锁</h4><p>形成条件：线程互相持有对方需要的资源—&gt;循环等待</p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200517161938174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>如何解决</strong>：破坏其中一个或多个条件即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试死锁</span></span><br><span class="line"><span class="comment"> *      多个线程互相拥有对方需要的资源，形成僵持</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-16 22:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lock1;</span><br><span class="line">    <span class="keyword">private</span> String lock2;</span><br><span class="line"></span><br><span class="line">    Player(String lock1, String lock2, String name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.lock1 = lock1;</span><br><span class="line">        <span class="keyword">this</span>.lock2 = lock2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//确保2线程都启动</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            noDeadLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死锁：持有锁，并想获得对方的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" have "</span> + lock1);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" need "</span> + lock2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//保证2线程都启动</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" get "</span> + lock2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决死锁：持有锁，等待对方放弃锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">noDeadLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" have "</span> + lock1);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" need "</span> + lock2);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放弃lock1,请求lock2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" get "</span> + lock2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String lock1 = <span class="keyword">new</span> String(<span class="string">"lock-V"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String lock2 = <span class="keyword">new</span> String(<span class="string">"lock-H"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Player a = <span class="keyword">new</span> Player(lock1, lock2, <span class="string">"A"</span>);</span><br><span class="line">        Player b = <span class="keyword">new</span> Player(lock2, lock1, <span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4）Lock锁"><a href="#4）Lock锁" class="headerlink" title="4）Lock锁"></a>4）Lock锁</h4><ul>
<li>JDK1.5 开始提供的显示锁。使用Lock对象</li>
<li><code>java.util.concurrent.locks.Lock</code>接口是控制多个线程对共享资源进行访问的工具。<br>锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，<strong>线程开始访问共享资源之前应先获得Lock对象</strong></li>
<li><code>ReentrantLock</code>（可重入锁）类实现了Lock，它拥有与<code>synchronized</code> 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是<code>ReentrantLock</code>，可以显式加锁、释放锁。</li>
</ul>
<p>示例：买票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Lock锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-21 9:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tickets2</span></span>&#123;</span><br><span class="line">    <span class="comment">// 票的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 买票的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"卖出了第"</span>+num--+<span class="string">"张票"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Tickets2 res = <span class="keyword">new</span> Tickets2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保线程启动</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                res.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                res.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                res.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A卖出了第<span class="number">20</span>张票</span><br><span class="line">A卖出了第<span class="number">19</span>张票</span><br><span class="line">A卖出了第<span class="number">18</span>张票</span><br><span class="line">A卖出了第<span class="number">17</span>张票</span><br><span class="line">A卖出了第<span class="number">16</span>张票</span><br><span class="line">A卖出了第<span class="number">15</span>张票</span><br><span class="line">A卖出了第<span class="number">14</span>张票</span><br><span class="line">A卖出了第<span class="number">13</span>张票</span><br><span class="line">B卖出了第<span class="number">12</span>张票</span><br><span class="line">B卖出了第<span class="number">11</span>张票</span><br><span class="line">B卖出了第<span class="number">10</span>张票</span><br><span class="line">B卖出了第<span class="number">9</span>张票</span><br><span class="line">B卖出了第<span class="number">8</span>张票</span><br><span class="line">B卖出了第<span class="number">7</span>张票</span><br><span class="line">B卖出了第<span class="number">6</span>张票</span><br><span class="line">B卖出了第<span class="number">5</span>张票</span><br><span class="line">C卖出了第<span class="number">4</span>张票</span><br><span class="line">C卖出了第<span class="number">3</span>张票</span><br><span class="line">C卖出了第<span class="number">2</span>张票</span><br><span class="line">C卖出了第<span class="number">1</span>张票</span><br></pre></td></tr></table></figure>

<h3 id="四、线程通信"><a href="#四、线程通信" class="headerlink" title="四、线程通信"></a>四、线程通信</h3><p>多个线程互相协作，共同完成任务。</p>
<p>涉及的方法</p>
<table>
<thead>
<tr>
<th>wait()</th>
<th>使当前线程进入阻塞,并释放锁</th>
</tr>
</thead>
<tbody><tr>
<td>wait(int time)</td>
<td>等待指定的毫秒数</td>
</tr>
<tr>
<td>notify()</td>
<td>唤醒一个等待该（对象锁）线程并使该线程开始执行</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>notifyAll 会唤醒所有等待该(对象锁)线程，</td>
</tr>
</tbody></table>
<p>注意： </p>
<ul>
<li><code>wait()、notify()、notifyAll()</code>是继承自Object的本地final方法</li>
<li>上面的方法需要配合<code>synchronized</code>关键字使用，即放在同步方法或代码块中使用。【<strong>说明当前线程已经获得锁</strong></li>
</ul>
<h4 id="1）生产者-消费者问题"><a href="#1）生产者-消费者问题" class="headerlink" title="1）生产者-消费者问题"></a>1）生产者-消费者问题</h4><ul>
<li>生产者—&gt;缓冲区   缓冲区满–&gt;等待消费</li>
<li>消费者&lt;—缓冲区   缓冲区空–&gt;等待生产</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.xu.multithread.kuangshen.pc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者--消费者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      生产者---&gt;缓冲区   缓冲区满--&gt;通知消费者消费</span></span><br><span class="line"><span class="comment"> *      消费者&lt;---缓冲区   缓冲区空--&gt;通知生产者生产</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实例：生产者，消费者，产品，缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-17 10:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="comment">//产品编号</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductBuffer</span></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区大小 5</span></span><br><span class="line">    List&lt;Product&gt; buffer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxCapacity = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将产品放入缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Product product)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 实际操作的是buffer，所以这里使用buffer锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (buffer)&#123;</span><br><span class="line">            <span class="comment">// 缓冲区满--&gt;放弃锁--&gt;阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (maxCapacity == buffer.size())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"缓冲区已满..."</span>);</span><br><span class="line">                    buffer.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//放入</span></span><br><span class="line">            buffer.add(product);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"生产了："</span>+product.i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知消费</span></span><br><span class="line">            buffer.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓冲区获取商品   synchronized锁的this==缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (buffer)&#123;</span><br><span class="line">            <span class="comment">// 缓冲区空--&gt;等待</span></span><br><span class="line">            <span class="keyword">while</span>(buffer.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//进入阻塞--&gt;放弃buffer锁</span></span><br><span class="line">                    System.out.println(<span class="string">"----&gt;缓冲区空了&lt;----"</span>);</span><br><span class="line">                    buffer.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//随机取出一个</span></span><br><span class="line">            Product product = buffer.remove(<span class="keyword">new</span> Random().nextInt(buffer.size()));</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;消费了："</span>+product.i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知生产</span></span><br><span class="line">            buffer.notifyAll();</span><br><span class="line">            <span class="comment">//返回产品</span></span><br><span class="line">            <span class="keyword">return</span> product;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ProductBuffer buffer = <span class="keyword">new</span> ProductBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者-1   </span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//放入10个产品</span></span><br><span class="line">                buffer.push(<span class="keyword">new</span> Product(i));</span><br><span class="line">                <span class="comment">//sleep(1000): 每生产一个就停一下</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者-2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">11</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//放入10个产品</span></span><br><span class="line">                buffer.push(<span class="keyword">new</span> Product(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者-1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                buffer.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者-2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">11</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                buffer.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A生产了：<span class="number">1</span></span><br><span class="line">A生产了：<span class="number">2</span></span><br><span class="line">A生产了：<span class="number">3</span></span><br><span class="line">A生产了：<span class="number">4</span></span><br><span class="line">A生产了：<span class="number">5</span></span><br><span class="line">缓冲区已满...</span><br><span class="line">B--&gt;消费了：<span class="number">1</span></span><br><span class="line">B--&gt;消费了：<span class="number">2</span></span><br><span class="line">B--&gt;消费了：<span class="number">5</span></span><br><span class="line">B--&gt;消费了：<span class="number">3</span></span><br><span class="line">B--&gt;消费了：<span class="number">4</span></span><br><span class="line">----&gt;缓冲区空了&lt;----</span><br><span class="line">C生产了：<span class="number">11</span></span><br><span class="line">C生产了：<span class="number">12</span></span><br><span class="line">C生产了：<span class="number">13</span></span><br><span class="line">C生产了：<span class="number">14</span></span><br><span class="line">C生产了：<span class="number">15</span></span><br><span class="line">缓冲区已满...</span><br><span class="line">B--&gt;消费了：<span class="number">12</span></span><br><span class="line">B--&gt;消费了：<span class="number">15</span></span><br><span class="line">B--&gt;消费了：<span class="number">13</span></span><br><span class="line">B--&gt;消费了：<span class="number">14</span></span><br><span class="line">B--&gt;消费了：<span class="number">11</span></span><br><span class="line">A生产了：<span class="number">6</span></span><br><span class="line">A生产了：<span class="number">7</span></span><br><span class="line">A生产了：<span class="number">8</span></span><br><span class="line">A生产了：<span class="number">9</span></span><br><span class="line">A生产了：<span class="number">10</span></span><br><span class="line">D--&gt;消费了：<span class="number">9</span></span><br><span class="line">D--&gt;消费了：<span class="number">10</span></span><br><span class="line">D--&gt;消费了：<span class="number">6</span></span><br><span class="line">D--&gt;消费了：<span class="number">7</span></span><br><span class="line">D--&gt;消费了：<span class="number">8</span></span><br><span class="line">----&gt;缓冲区空了&lt;----</span><br><span class="line">C生产了：<span class="number">16</span></span><br><span class="line">C生产了：<span class="number">17</span></span><br><span class="line">C生产了：<span class="number">18</span></span><br><span class="line">C生产了：<span class="number">19</span></span><br><span class="line">C生产了：<span class="number">20</span></span><br><span class="line">D--&gt;消费了：<span class="number">20</span></span><br><span class="line">D--&gt;消费了：<span class="number">19</span></span><br><span class="line">D--&gt;消费了：<span class="number">16</span></span><br><span class="line">D--&gt;消费了：<span class="number">18</span></span><br><span class="line">D--&gt;消费了：<span class="number">17</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8-Stream流</title>
    <url>/2020/05/22/Java8--Stream%E6%B5%81/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>java.util.Stream</code> 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如<code>java.util.Collection</code> 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。</p>
<a id="more"></a>

<h3 id="一、流的创建方式"><a href="#一、流的创建方式" class="headerlink" title="一、流的创建方式"></a>一、流的创建方式</h3><blockquote>
<ol>
<li>从Collection(集合)中构建；</li>
<li>从值<code>value</code>(<code>Stream.of()</code>)中构建；</li>
<li>从数组中构建(<code>Arrays.stream()</code>)；</li>
<li>从文件中构建；</li>
<li>由函数生成: 创建无限流；</li>
</ol>
</blockquote>
<p>1）从集合中获取流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从集合中获取流</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"bb"</span>);</span><br><span class="line">        list.add(<span class="string">"ccc"</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">        <span class="comment">//流只能使用一次，第二次需要重新获取</span></span><br><span class="line">        <span class="comment">//报：stream has already been operated upon or closed</span></span><br><span class="line">        <span class="comment">//stream.forEach(x -&gt; System.out.println(x));</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2）使用<code>Stream.of()</code>获取流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从值`value`(`Stream.of()`)中构建；</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">      stream.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>3）使用<code>Arrays.stream()</code>从数组中获取流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从数组中构建(`Arrays.stream()`)；</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromArrays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     String[] arr = &#123;<span class="string">"aa"</span>, <span class="string">"ee"</span>, <span class="string">"ii"</span>&#125;;</span><br><span class="line">     Stream&lt;String&gt; stream = Arrays.stream(arr);</span><br><span class="line">     stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>4）从文件中获取流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从文件中创建流</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     Path path = Paths.get(<span class="string">"D:\\IdeaProjects\\DataStructure\\Data\\src\\pers\\xu\\lambda\\LambdaDemo.java"</span>);</span><br><span class="line">     Stream&lt;String&gt; stream = Files.lines(path);</span><br><span class="line">     stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>5）使用函数创建无效流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数创建的无限流-1</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromIterate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">2</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">5</span>);</span><br><span class="line">       stream.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 函数创建的无限流-2</span></span><br><span class="line">   <span class="comment">// Stream.generate(生产者接口)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromGenerate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Stream&lt;Double&gt; stream = Stream.generate(Math::random).limit(<span class="number">5</span>);</span><br><span class="line">       stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//类名::静态方法    实例参数列表要与抽象方法的参数列表一致</span></span><br><span class="line">       <span class="comment">//Stream&lt;Double&gt; stream2 = Stream.generate(()-&gt;Math.random()).limit(5);</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>6）示例：创建一个提供Custom对象的无限流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Custom</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Custom</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Custom</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Custom</span><span class="params">(<span class="keyword">int</span> id, String name)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Custom&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Custom o1, Custom o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.id-o2.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类实现 供给型接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CusSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Custom</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Custom <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       index=random.nextInt(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Custom(index,<span class="string">"name-"</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建流</span></span><br><span class="line">        <span class="comment">//generate()：参数接收一个供给型接口</span></span><br><span class="line">        Stream&lt;Custom&gt; stream = Stream.generate(<span class="keyword">new</span> CusSupplier()).</span><br><span class="line">                limit(<span class="number">5</span>).</span><br><span class="line">                sorted(Comparator.comparing(Custom::getId)); <span class="comment">//根据id进行排序</span></span><br><span class="line">        <span class="comment">//sorted(new Custom());</span></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line">        <span class="comment">//创建流</span></span><br><span class="line">        <span class="comment">//generate()：参数接收一个供给型接口.</span></span><br><span class="line">        <span class="comment">//作用：无限生成流元素</span></span><br><span class="line">        List&lt;Custom&gt; list = Stream.generate(<span class="keyword">new</span> CusSupplier()).</span><br><span class="line">                limit(<span class="number">3</span>).</span><br><span class="line">                sorted(<span class="keyword">new</span> Custom()) <span class="comment">//Custom实现了Comparator接口</span></span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Custom custom : list) &#123;</span><br><span class="line">            System.out.println(custom);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、流的中间操作"><a href="#二、流的中间操作" class="headerlink" title="二、流的中间操作"></a>二、流的中间操作</h3><blockquote>
<p> filter、limit、skip、map、flatMap的使用</p>
<ul>
<li>filter：过滤</li>
<li>limit：返回一个不超过给定长度的流；</li>
<li>skip：返回一个扔掉了前n 个元素的流；【skip(k)：跳过前k个元素</li>
<li>map：将流中元素其映射成一个新的元素</li>
<li>flatMap：把一个流中的每个值都换成另一个流，然后把所有的流连接</li>
</ul>
</blockquote>
<p>1）filter()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * filter : 接收一个断言式接口（Predicate）作为参数，</span></span><br><span class="line"><span class="comment">    * 			并返回一个包括所有符合条件的元素的流；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Integer&gt; nums = Arrays.asList(<span class="number">10</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">       <span class="comment">//从流中选出偶数，且没有重复</span></span><br><span class="line">       nums.stream().filter(i -&gt; i%<span class="number">2</span>==<span class="number">0</span>)  <span class="comment">//过滤</span></span><br><span class="line">               .distinct()  <span class="comment">//去重</span></span><br><span class="line">               .sorted((x,y) -&gt; y.compareTo(x)) <span class="comment">//排序</span></span><br><span class="line">               .forEach(x -&gt; System.out.println(x+<span class="string">"-"</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>2）limit()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * limit ():</span></span><br><span class="line"><span class="comment">   *      流支持`limit(n)`方法，该方法会返回一个不超过给定长度的流；</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">      String[] arr = &#123;<span class="string">"aa"</span>,<span class="string">"b"</span>,<span class="string">"cc"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">     Arrays.stream(arr).</span><br><span class="line">             limit(<span class="number">3</span>). <span class="comment">//取前3个</span></span><br><span class="line">             forEach(System.out::println);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>3）skip()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * skip():</span></span><br><span class="line"><span class="comment">    *      返回一个扔掉了前n 个元素的流；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSkip</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String[] arr = &#123;<span class="string">"aa"</span>,<span class="string">"b"</span>,<span class="string">"cc"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">       Arrays.stream(arr).</span><br><span class="line">               skip(<span class="number">2</span>). <span class="comment">//跳过前2个 [aa,b</span></span><br><span class="line">               forEach(System.out::println);</span><br><span class="line">       <span class="comment">//结果：cc d</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>4）map()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * map()：</span></span><br><span class="line"><span class="comment">    *      这个函数会被应用到每个元素上，</span></span><br><span class="line"><span class="comment">    *      把流中的元素‘转换’为另一个元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">       nums.stream().map(i -&gt; i*<span class="number">2</span> ) <span class="comment">//将流中元素都转换为2倍</span></span><br><span class="line">               .collect(Collectors.toList())</span><br><span class="line">               .forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * map()示例：</span></span><br><span class="line"><span class="comment">    * 将字符串元素转换为它的长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;String&gt; strs = Arrays.asList(<span class="string">"a"</span>, <span class="string">"bb"</span>, <span class="string">"ccc"</span>, <span class="string">"dd"</span>);</span><br><span class="line">       strs.stream().map(x -&gt; x.length())</span><br><span class="line">               .collect(Collectors.toList())</span><br><span class="line">               .forEach(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>5）flatmap()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * flatmap()：</span></span><br><span class="line"><span class="comment">    *      把一个流中的每个值都换成另一个流，</span></span><br><span class="line"><span class="comment">    *      然后把所有的流连接起来成为一个流</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//将 words去重输出字符</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String[] arr = &#123;<span class="string">"Hello"</span>,<span class="string">"Tom"</span>,<span class="string">"House"</span>&#125;;</span><br><span class="line">       <span class="comment">//把一个字符串变成了一个字符串数组</span></span><br><span class="line">       Stream&lt;String[]&gt; stream = Arrays.stream(arr).</span><br><span class="line">               map(x -&gt; x.split(<span class="string">""</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">//stream.forEach(arr2 -&gt; System.out.println("str-length:"+arr2.length));</span></span><br><span class="line"></span><br><span class="line">       Stream&lt;String&gt; stringStream = stream.flatMap(s -&gt; Arrays.stream(s));</span><br><span class="line"></span><br><span class="line">       stringStream.</span><br><span class="line">               distinct().</span><br><span class="line">               forEach(x -&gt; System.out.print(x+<span class="string">"-"</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、流的终止操作"><a href="#三、流的终止操作" class="headerlink" title="三、流的终止操作"></a>三、流的终止操作</h3><blockquote>
<p> <strong>终端操作</strong>会<strong>从 流的流水线 生成结果</strong>。<br>不做终止操作，中间环节就不执行，体现的就是延迟加载的思想；<br>只有用的时候，中间环节再进行。<br>其<strong>结果</strong>可以是<strong>任何不是流的值</strong><br>例如：List、Integer，甚至是 void </p>
</blockquote>
<blockquote>
<ul>
<li>match：查看元素是否匹配(返回<strong>boolean</strong>)，<ul>
<li><code>allMatch()</code>: 检查<strong>是否匹配所有元素</strong> </li>
<li><code>anyMatch()</code> : 检查<strong>是否至少匹配一个元素</strong> </li>
<li><code>noneMatch()</code>: 检查<strong>是否与 所有元素 都不匹配</strong> </li>
</ul>
</li>
<li>find：<ul>
<li><code>isPresent()</code>将在Optional包含值的时候返回true, 否则返回false；</li>
<li>ifPresent(Consumer<T> block)`会在值存在的时候执行给定的代码块；</li>
<li><code>T get()</code>会在值存在时返回值，否则抛出一个NoSuchElement异常；</li>
<li><code>T orElse(T other)</code>会在值存在时返回值，否则返回一个默认值；</li>
<li><code>Optional&lt;T&gt; of(T value)</code>  : 通过value构造一个Optional；</li>
</ul>
</li>
<li>max(Comparator c)：  返回<strong>流中最大值</strong> </li>
<li>min(Comparator c)：返回<strong>流中最小值</strong> </li>
<li>forEach(Consumer c)：<strong>内部迭代</strong> </li>
<li>reduce()：<ul>
<li>把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。</li>
<li>从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。</li>
<li>例如 Stream 的 sum 就相当于<code>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);</code></li>
<li>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</li>
</ul>
</li>
</ul>
</blockquote>
<p>1）count()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * count():</span></span><br><span class="line"><span class="comment">    *      对流中的元素进行计数，返回一个long类型值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">           list.add(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//list中奇数的个数</span></span><br><span class="line">       <span class="keyword">long</span> count = list.stream().</span><br><span class="line">               filter(x -&gt; x % <span class="number">2</span> == <span class="number">1</span>).count();</span><br><span class="line"></span><br><span class="line">       System.out.println(count);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>2）match()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matchTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    out.println(arr.stream().allMatch(i -&gt; i &gt; <span class="number">10</span>));</span><br><span class="line">    out.println(arr.stream().anyMatch(i -&gt; i &gt; <span class="number">6</span>));</span><br><span class="line">    out.println(arr.stream().noneMatch(i -&gt; i &lt; <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    Optional&lt;Integer&gt; any = arr.stream().filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).findAny();</span><br><span class="line">    out.println(any.get());</span><br><span class="line"></span><br><span class="line">    Optional&lt;Integer&gt; first = arr.stream().filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).findFirst();</span><br><span class="line">    first.ifPresent(out::println);</span><br><span class="line">    out.println(first.get()); <span class="comment">//没有就抛出 NoSuchElementException</span></span><br><span class="line">    out.println(first.orElse(-<span class="number">1</span>)); <span class="comment">// 如果first为空就输出-1</span></span><br><span class="line"></span><br><span class="line">    System.out.println(first.filter(i -&gt; i == <span class="number">2</span>).get()); <span class="comment">// Optional还会产生一个stream</span></span><br><span class="line">    System.out.println(find(arr, -<span class="number">1</span>, i -&gt; i &gt; <span class="number">10</span>)); <span class="comment">// 自己写的一个防止空指针的，而Optional中有一个已经存在的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(List&lt;Integer&gt; values, <span class="keyword">int</span> defaultValue, Predicate&lt;Integer&gt; predicate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> val : values)&#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(val))</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reduceTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    System.out.println(arr.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b)); <span class="comment">//计算数组的和 ,有初始值就是Integer</span></span><br><span class="line">    arr.stream().reduce((a, b) -&gt; a + b).ifPresent(out::println); <span class="comment">// 没有初始值就是 Optional</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取所有的偶数相乘</span></span><br><span class="line">    <span class="keyword">int</span> res = arr.stream().filter(x -&gt; x%<span class="number">2</span> == <span class="number">0</span>).reduce(<span class="number">1</span>, (a, b) -&gt; a*b);</span><br><span class="line">    Optional.of(res).ifPresent(out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、串行流与并行流"><a href="#四、串行流与并行流" class="headerlink" title="四、串行流与并行流"></a>四、串行流与并行流</h3><blockquote>
<p>Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p>
</blockquote>
<p>使用：就是将 <code>stream()</code> 改为<code>parallelStream()</code>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8-Lambda表达式</title>
    <url>/2020/05/22/Java8--Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="一、Lambda基础语法"><a href="#一、Lambda基础语法" class="headerlink" title="一、Lambda基础语法"></a>一、Lambda基础语法</h3><p>1）<code>-&gt;</code>：箭头表达式</p>
<ul>
<li><p>箭头左边：参数列表   ，无参使用() </p>
</li>
<li><p>箭头右边：实现接口中抽象方法的实现代码</p>
</li>
</ul>
<p>2）只有一个参数的话，可以省略参数的括号实现</p>
<p>3）只有一条语句的话，可以省略大括号，也可省略<code>return</code>关键字</p>
<a id="more"></a>

<h3 id="二、Lambda的实质"><a href="#二、Lambda的实质" class="headerlink" title="二、Lambda的实质"></a>二、Lambda的实质</h3><p>对接口的唯一抽象方法的实现</p>
<h3 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h3><p>先举个例子：</p>
<p>未使用Lambda:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"go to school"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       t1.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>使用Lambda</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Go to school"</span>)).start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、四大函数式接口"><a href="#四、四大函数式接口" class="headerlink" title="四、四大函数式接口"></a>四、四大函数式接口</h3><h4 id="1）消费者接口"><a href="#1）消费者接口" class="headerlink" title="1）消费者接口"></a>1）消费者接口</h4><blockquote>
<p>无返回值，对传入的参数操作即可</p>
</blockquote>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   	<span class="comment">// 接收一个泛型T</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：接收一个字符串并打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.8 提供的消费者的接口</span></span><br><span class="line">        Consumer&lt;String&gt; con = x -&gt; System.out.println(<span class="string">"accept: "</span>+x);</span><br><span class="line">        con.accept(<span class="string">"Tom"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 输出：accept Tom</span></span><br></pre></td></tr></table></figure>

<h4 id="2）供应者接口"><a href="#2）供应者接口" class="headerlink" title="2）供应者接口"></a>2）供应者接口</h4><blockquote>
<p>返回一个T类型</p>
</blockquote>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 返回给定的泛型参数类型</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：生成一个随机数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// 只有一句，return可以省略</span></span><br><span class="line">      Supplier&lt;Integer&gt; sup = () -&gt; Integer.valueOf(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">      Integer val = sup.get();</span><br><span class="line">      System.out.println(val);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）判断式接口"><a href="#3）判断式接口" class="headerlink" title="3）判断式接口"></a>3）判断式接口</h4><blockquote>
<p>对传入的泛型参数做boolean判断</p>
</blockquote>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//判断</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String str = <span class="string">"hell"</span>;</span><br><span class="line">       <span class="keyword">boolean</span> bool = isEmpty(str, s -&gt; s.isEmpty());</span><br><span class="line">       System.out.println(bool);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(String str, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pre.test(str);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4）函数式接口"><a href="#4）函数式接口" class="headerlink" title="4）函数式接口"></a>4）函数式接口</h4><blockquote>
<p>接收一个泛型T,返回一个泛型R</p>
</blockquote>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   	 * 根据t，返回一个R类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例：通过一个名字创建一个用户</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                    <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User tom = createUser(<span class="string">"Tom"</span>, name -&gt; <span class="keyword">new</span> User(name));</span><br><span class="line">        System.out.println(tom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">createUser</span><span class="params">(String name, Function&lt;String,User&gt; fun)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fun.apply(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User&#123;name=<span class="string">'Tom'</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、方法引用"><a href="#五、方法引用" class="headerlink" title="五、方法引用"></a>五、方法引用</h3><blockquote>
<p>下表引用自：<a> <a href="https://www.cnblogs.com/wuhenzhidu/p/10727065.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuhenzhidu/p/10727065.html</a> 侵删</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>语法</th>
<th>对应的Lambda表达式</th>
</tr>
</thead>
<tbody><tr>
<td>静态方法引用</td>
<td>类名::staticMethod</td>
<td>(args) -&gt; 类名.staticMethod(args)</td>
</tr>
<tr>
<td>实例方法引用</td>
<td>inst::instMethod</td>
<td>(args) -&gt; inst.instMethod(args)</td>
</tr>
<tr>
<td>对象方法引用</td>
<td>类名::instMethod</td>
<td>(inst,args) -&gt; 类名.instMethod(args)</td>
</tr>
<tr>
<td>构建方法引用</td>
<td>类名::new</td>
<td>(args) -&gt; new 类名(args)</td>
</tr>
</tbody></table>
<h4 id="1）静态方法引用"><a href="#1）静态方法引用" class="headerlink" title="1）静态方法引用"></a>1）静态方法引用</h4><blockquote>
<p>抽象方法的参数列表要和调用的静态方法的参数一致</p>
<p>格式：类名::静态方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">    <span class="comment">//简写</span></span><br><span class="line">    Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）实例方法引用"><a href="#2）实例方法引用" class="headerlink" title="2）实例方法引用"></a>2）实例方法引用</h4><blockquote>
<p>抽象方法的参数要和实例方法参数一致</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Consumer&lt;String&gt; consumer = x-&gt; System.out.println(x);</span><br><span class="line">       <span class="comment">//简写</span></span><br><span class="line">       consumer = System.out::println;</span><br><span class="line"></span><br><span class="line">       consumer.accept(<span class="string">"Hello"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）对象方法引用"><a href="#3）对象方法引用" class="headerlink" title="3）对象方法引用"></a>3）对象方法引用</h4><blockquote>
<p>Lambda参数列表中的第一个参数是实例方法的调用者、第二个是实例方法参数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y);</span><br><span class="line">    BiPredicate&lt;String, String&gt; bp2 = String::equals;</span><br><span class="line">    <span class="comment">//Lambda参数列表中的第一个参数x,是实例方法的第一个调用者x。</span></span><br><span class="line">    <span class="comment">//第二个参数y是实例方法的参数y。则可以使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4）构造方法引用"><a href="#4）构造方法引用" class="headerlink" title="4）构造方法引用"></a>4）构造方法引用</h4><blockquote>
<p>构造器的参数列表和抽象方法列表一致</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Supplier&lt;User&gt; supplier1 = ()-&gt; <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">      Supplier&lt;User&gt; supplier2 = User::<span class="keyword">new</span>;</span><br><span class="line">      User user = supplier.get();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-JUC编程（2）</title>
    <url>/2020/05/25/Java-JUC%E7%BC%96%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、阻塞队列"><a href="#一、阻塞队列" class="headerlink" title="一、阻塞队列"></a>一、阻塞队列</h3><blockquote>
<p>java.util.concurrent.BolckingQueue    ：是一个接口</p>
<p><img src="https://img-blog.csdnimg.cn/20200525110303505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>继承关系：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200525110317249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>生产者-消费者模型</strong></p>
</blockquote>
<a id="more"></a>

<h4 id="1）4组API"><a href="#1）4组API" class="headerlink" title="1）4组API"></a>1）4组API</h4><blockquote>
<p>什么情况下我们会使用 阻塞队列：<strong>多线程并发处理，线程池！</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>有返回值，不抛出异常</th>
<th>阻塞 等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add(E e)</td>
<td>offer(E e) 满–&gt;false</td>
<td>put(Ee)</td>
<td>offer(E e,long timeout,TimeUint unit)</td>
</tr>
<tr>
<td>删除</td>
<td>remove()</td>
<td>poll() 空–&gt;null</td>
<td>teke()</td>
<td>poll()</td>
</tr>
<tr>
<td>检测队首元素</td>
<td>element()</td>
<td>peek()</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>队列满</strong></td>
<td>报异常</td>
<td>返回false</td>
<td>无限等待</td>
<td>等待一段时间任然满–&gt;false</td>
</tr>
<tr>
<td><strong>队列空</strong></td>
<td>报异常</td>
<td>返回null</td>
<td>无限等待</td>
<td>等待一段时间任然空–&gt;null</td>
</tr>
</tbody></table>
<p> 使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRemove</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// 队列容量</span></span><br><span class="line">       BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">       queue.add(<span class="number">1</span>);</span><br><span class="line">       queue.add(<span class="number">2</span>);</span><br><span class="line">       queue.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 报：Exception in thread "main" java.lang.IllegalStateException: Queue full</span></span><br><span class="line">       <span class="comment">//queue.add(4);</span></span><br><span class="line"></span><br><span class="line">       queue.remove();</span><br><span class="line">       queue.remove();</span><br><span class="line">       queue.remove();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 报：Exception in thread "main" java.util.NoSuchElementException</span></span><br><span class="line">       queue.remove();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// offer(),poll()   无异常，false或null</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offerPoll</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// 队列容量</span></span><br><span class="line">       BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">       queue.offer(<span class="number">1</span>);</span><br><span class="line">       queue.offer(<span class="number">2</span>);</span><br><span class="line">       queue.offer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 无异常，返回false</span></span><br><span class="line">       System.out.println(queue.offer(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">       queue.poll();</span><br><span class="line">       queue.poll();</span><br><span class="line">       queue.poll();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 无异常，返回null</span></span><br><span class="line">       System.out.println(queue.poll());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// put(),take()    会阻塞</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putTake</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">// 队列容量</span></span><br><span class="line">       BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">       queue.put(<span class="number">1</span>);</span><br><span class="line">       queue.put(<span class="number">2</span>);</span><br><span class="line">       queue.put(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 无异常，一直阻塞</span></span><br><span class="line">       queue.put(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">       queue.take();</span><br><span class="line">       queue.take();</span><br><span class="line">       queue.take();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 无异常，一直阻塞</span></span><br><span class="line">       System.out.println(queue.take());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞队列4组API</span></span><br><span class="line"><span class="comment"> *      add(),remove()</span></span><br><span class="line"><span class="comment"> *      offer(),poll()</span></span><br><span class="line"><span class="comment"> *      put(),take()</span></span><br><span class="line"><span class="comment"> *      offer(,,),poll(,,)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-24 8:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBlockingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// offer(,,),poll(,,)   无异常,超时等待，false或null</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offerPollTimeOut</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 队列容量</span></span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        queue.offer(<span class="number">1</span>);</span><br><span class="line">        queue.offer(<span class="number">2</span>);</span><br><span class="line">        queue.offer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无异常，返回false</span></span><br><span class="line">        System.out.println(queue.offer(<span class="number">4</span>,<span class="number">3</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无异常，返回null</span></span><br><span class="line">        System.out.println(queue.poll(<span class="number">3</span>,TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"timeout..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、同步队列"><a href="#二、同步队列" class="headerlink" title="二、同步队列"></a>二、同步队列</h3><blockquote>
<p>特殊的阻塞队列，容量=1</p>
<ul>
<li>放入一个后，必须等待取出</li>
<li>取出后，必须等待放入</li>
</ul>
<p>典型<strong>生产者-消费者</strong>模型</p>
<p><img src="https://img-blog.csdnimg.cn/2020052511034236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.xu.multithread.kuangshen.juc.block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-25 10:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Res</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里不能加synchronized   ,因为put()会一直等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" put: "</span>+a);</span><br><span class="line">        blockingQueue.put(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Integer ret = blockingQueue.take();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" get: "</span>+ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronousQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Res res = <span class="keyword">new</span> Res();</span><br><span class="line">        <span class="comment">// 放入</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.put(i);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A put: <span class="number">0</span></span><br><span class="line">B get: <span class="number">0</span></span><br><span class="line">A put: <span class="number">1</span></span><br><span class="line">B get: <span class="number">1</span></span><br><span class="line">A put: <span class="number">2</span></span><br><span class="line">B get: <span class="number">2</span></span><br><span class="line">A put: <span class="number">3</span></span><br><span class="line">B get: <span class="number">3</span></span><br><span class="line">A put: <span class="number">4</span></span><br><span class="line">B get: <span class="number">4</span></span><br><span class="line">A put: <span class="number">5</span></span><br><span class="line">B get: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="三、读写锁"><a href="#三、读写锁" class="headerlink" title="三、读写锁"></a>三、读写锁</h3><blockquote>
<p><strong>什么是读写锁？</strong></p>
<p>并发情况下：</p>
<ul>
<li>可以允许多个线程同时读，但只允许一个线程在写</li>
<li>读写不能同时进行</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200525110403847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.lang.model.element.VariableElement;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 独占锁---&gt;写锁</span></span><br><span class="line"><span class="comment"> * 共享锁---&gt;读锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 读写锁：允许多个线程同时读，不允许同时写，每次只能有一个线程在写</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      读-读：允许</span></span><br><span class="line"><span class="comment"> *      读-写：互斥，不允许</span></span><br><span class="line"><span class="comment"> *      写-写：更不允许</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-21 23:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//创建读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,String value)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取写锁</span></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"写入："</span>+key);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"写入结束："</span>+key+<span class="string">"\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁，还是和之前ReentrantLock一样用法</span></span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取读锁</span></span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"读："</span>+key);</span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"读结束："</span>+value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放读锁</span></span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReadWriteLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyCache cache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启5个线程写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                cache.write(temp+<span class="string">""</span>,temp+<span class="string">""</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5个线程读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                cache.read(temp+<span class="string">""</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从执行结果看：保证了写的唯一性，但读共享的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>写入：<span class="number">1</span></span><br><span class="line"><span class="number">1</span>写入结束：<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>写入：<span class="number">3</span></span><br><span class="line"><span class="number">3</span>写入结束：<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>写入：<span class="number">4</span></span><br><span class="line"><span class="number">4</span>写入结束：<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>写入：<span class="number">0</span></span><br><span class="line"><span class="number">0</span>写入结束：<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>写入：<span class="number">2</span></span><br><span class="line"><span class="number">2</span>写入结束：<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>读：<span class="number">0</span></span><br><span class="line"><span class="number">4</span>读：<span class="number">4</span></span><br><span class="line"><span class="number">4</span>读结束：<span class="number">4</span></span><br><span class="line"><span class="number">1</span>读：<span class="number">1</span></span><br><span class="line"><span class="number">0</span>读结束：<span class="number">0</span></span><br><span class="line"><span class="number">2</span>读：<span class="number">2</span></span><br><span class="line"><span class="number">3</span>读：<span class="number">3</span></span><br><span class="line"><span class="number">2</span>读结束：<span class="number">2</span></span><br><span class="line"><span class="number">1</span>读结束：<span class="number">1</span></span><br><span class="line"><span class="number">3</span>读结束：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h3 id="四、线程池"><a href="#四、线程池" class="headerlink" title="四、线程池"></a>四、线程池</h3><blockquote>
<p><strong>什么是线程池？</strong></p>
<ul>
<li>线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。</li>
<li>由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能。 </li>
</ul>
<p>充分利用系统的资源！ 优化资源的使用！=&gt;池化技术</p>
<p><strong>2. 线程池的优点</strong>: </p>
<p>1、降低资源的消耗</p>
<p>2、提高响应的速度 </p>
<p>3、方便管理。</p>
<p><strong>3. 线程池用途</strong></p>
<p>线程复用、可以<strong>控制最大并发数</strong>、<strong>管理线程</strong></p>
<p><strong>3. 线程池要点</strong></p>
<p><font color=red>3大方法，7大参数，4种拒绝策略</font></p>
</blockquote>
<h4 id="1）基本使用"><a href="#1）基本使用" class="headerlink" title="1）基本使用"></a>1）基本使用</h4><blockquote>
<p><code>Executors</code>工具类创建线程池</p>
<table>
<thead>
<tr>
<th>newSingleThreadExecutor()</th>
<th>创建只有一个线程的线程池</th>
</tr>
</thead>
<tbody><tr>
<td>newFixedThreadPool（int n)</td>
<td>创建固定数量线程的线程池</td>
</tr>
<tr>
<td>newCachedThreadPool()</td>
<td>创建可伸缩大小的线程池</td>
</tr>
</tbody></table>
</blockquote>
<p><strong>3大方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executors工具类：三大方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-22 8:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecutors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 里面只有一个线程</span></span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"hello"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        pool-1-thread-1hello</span></span><br><span class="line"><span class="comment">        pool-1-thread-1hello</span></span><br><span class="line"><span class="comment">        pool-1-thread-1hello</span></span><br><span class="line"><span class="comment">        pool-1-thread-1hello</span></span><br><span class="line"><span class="comment">        pool-1-thread-1hello</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定池中线程数量</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" :hello"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可伸缩大小线程池</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" :hello"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）自定义线程池"><a href="#2）自定义线程池" class="headerlink" title="2）自定义线程池"></a>2）自定义线程池</h4><blockquote>
<p>使用<code>Executors</code>创建线程池源码分析：</p>
<p><img src="https://img-blog.csdnimg.cn/20200525110435431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200525110450423.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200525110503671.png#pic_center" alt="在这里插入图片描述"></p>
<p>可以发现，3个都是在调用<code>ThreadPoolExecutor</code>创建线程池</p>
<p><img src="https://img-blog.csdnimg.cn/20200525110517277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<p>7大参数：</p>
<table>
<thead>
<tr>
<th>corePoolSize</th>
<th>核心线程数</th>
<th>默认是核心线程保持活动在处理任务</th>
</tr>
</thead>
<tbody><tr>
<td>maximumPoolSize</td>
<td>最大线程数</td>
<td>当任务数量&gt;核心线程数+阻塞队列size时，开启新线程处理</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>超时等待时间</td>
<td>【指已经达到最大maxPoolSize+阻塞队列size后</td>
</tr>
<tr>
<td>TimeUnit</td>
<td>时间单位</td>
<td></td>
</tr>
<tr>
<td>BlockingQueue</td>
<td>阻塞队列</td>
<td>当任务数量&gt;核心线程数时，新任务进入阻塞队列</td>
</tr>
<tr>
<td>ThreadFactory</td>
<td>线程工厂</td>
<td></td>
</tr>
<tr>
<td>RejectedExecutionHandler</td>
<td>拒绝策略：</td>
<td>【指已经达到最大maxPoolSize+阻塞队列size后进来的任务如何处理</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * AbortPolicy: 报异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取cpu核数</span></span><br><span class="line">       <span class="keyword">int</span> maxSize = Runtime.getRuntime().availableProcessors();</span><br><span class="line">       System.out.println(maxSize); <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">       ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">               <span class="number">2</span>,</span><br><span class="line">               <span class="number">5</span>,</span><br><span class="line">               <span class="number">2</span>,</span><br><span class="line">               TimeUnit.SECONDS,</span><br><span class="line">               <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">               Executors.defaultThreadFactory(),  <span class="comment">// 默认线程工厂</span></span><br><span class="line">               <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy() <span class="comment">//解决策略，上面三个默认都是使用这个</span></span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 阻塞队列size=3   coreSize=2   maxPoolSize=5</span></span><br><span class="line">       <span class="comment">// 2: 只有2个线程在处理</span></span><br><span class="line">       <span class="comment">// 5: 只有2个线程在处理,3个在阻塞队列里</span></span><br><span class="line">       <span class="comment">// 6: 达最大poolSize,又开启一个线程处理  【此时3个线程</span></span><br><span class="line">       <span class="comment">// 7: 又开启一个线程处理  【此时4个线程</span></span><br><span class="line">       <span class="comment">// 8：又开启一个线程处理  【此时5个线程</span></span><br><span class="line">       <span class="comment">// 9: 报异常java.util.concurrent.RejectedExecutionException。【AbortPolicy策略</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 总结：最大可处理任务数量=maxPoolSize+阻塞队列size</span></span><br><span class="line">       <span class="comment">// 默认是核心线程保持活动在处理任务</span></span><br><span class="line">       <span class="comment">// 当任务数量&gt;核心线程数+阻塞队列size时，开启新线程处理</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">               executor.execute(() -&gt; &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">" : hello"</span>);</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 归还连接</span></span><br><span class="line">           executor.shutdown();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>4中拒绝策略</p>
<blockquote>
<p>三大方法默认使用的是<code>Abort</code>策略。【即：报异常策略</p>
</blockquote>
<table>
<thead>
<tr>
<th>new ThreadPoolExecutor.AbortPolicy()</th>
<th>银行满了，还有人进来，不处理这个人的，抛出异 常</th>
</tr>
</thead>
<tbody><tr>
<td>new ThreadPoolExecutor.CallerRunsPolicy()</td>
<td>哪来的去哪里！</td>
</tr>
<tr>
<td>new ThreadPoolExecutor.DiscardPolicy()</td>
<td>队列满了，丢掉任务，不会抛出异常！</td>
</tr>
<tr>
<td>new ThreadPoolExecutor.DiscardOldestPolicy()</td>
<td>队列满了，尝试去和早的竞争，也不会 抛出异常！</td>
</tr>
</tbody></table>
<h4 id="3）CPU-IO-密集型"><a href="#3）CPU-IO-密集型" class="headerlink" title="3）CPU/IO 密集型"></a>3）CPU/IO 密集型</h4><blockquote>
<p><strong>池的大的大小如何去设置？</strong><br>了解：IO密集型，CPU密集型：（调优）</p>
</blockquote>
<ul>
<li>CPU密集型：电脑几核，就是几，可以保持CPu的效率高！ </li>
<li>IO密集型：判断你程序中十分耗IO的线程， 比如有15个很耗IO的操作，那么我们设置池大小为30就好了【一般设置为2倍</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取CPU的核数        </span></span><br><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure>

<h3 id="五、ForkJoin详解"><a href="#五、ForkJoin详解" class="headerlink" title="五、ForkJoin详解"></a>五、ForkJoin详解</h3><blockquote>
<p>什么是ForkJoin?</p>
<p>分治+合并</p>
</blockquote>
<p>ForkJoin 在 JDK 1.7 ， 并行执行任务！</p>
<p>提高效率。大数据量！ 大数据：Map Reduce （把大任务拆分为小任务）</p>
<p><img src="https://img-blog.csdnimg.cn/20200525110558259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>ForkJoin特点：工作窃取</p>
</blockquote>
<p>这个里面维护的都是双端队列</p>
<p><img src="https://img-blog.csdnimg.cn/2020052511061172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>API描述：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2020052511062498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.xu.multithread.kuangshen.juc.forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求和计算的任务！</span></span><br><span class="line"><span class="comment"> * 3000   6000（ForkJoin）  9000（Stream并行流）</span></span><br><span class="line"><span class="comment"> * // 如何使用 forkjoin</span></span><br><span class="line"><span class="comment"> * // 1、forkjoinPool 通过它来执行</span></span><br><span class="line"><span class="comment"> * // 2、计算任务 forkjoinPool.execute(ForkJoinTask task)</span></span><br><span class="line"><span class="comment"> * // 3. 计算类要继承 ForkJoinTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> Long end;    <span class="comment">// 1990900000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界值</span></span><br><span class="line">    <span class="keyword">private</span> Long temp = <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//小于10000使用普通方法求和</span></span><br><span class="line">        <span class="keyword">if</span> ((end-start)&lt;temp)&#123;</span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// forkjoin 递归</span></span><br><span class="line">            <span class="keyword">long</span> middle = (start + end) / <span class="number">2</span>; <span class="comment">// 中间值</span></span><br><span class="line">            ForkJoinDemo task1 = <span class="keyword">new</span> ForkJoinDemo(start, middle);</span><br><span class="line">            task1.fork(); <span class="comment">// 拆分任务，把任务压入线程队列</span></span><br><span class="line">            ForkJoinDemo task2 = <span class="keyword">new</span> ForkJoinDemo(middle+<span class="number">1</span>, end);</span><br><span class="line">            task2.fork(); <span class="comment">// 拆分任务，把任务压入线程队列</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 完成后合并</span></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.xu.multithread.kuangshen.juc.forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.DoubleStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算1-100000000和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">         <span class="comment">//test1(); // 8800</span></span><br><span class="line">         <span class="comment">//test2(); // 8012</span></span><br><span class="line">         <span class="comment">//test3(); // 307</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通程序员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Long i = <span class="number">1L</span>; i &lt;= <span class="number">10_0000_0000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sum="</span>+sum+<span class="string">" 时间："</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会使用ForkJoin</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinDemo(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);<span class="comment">// 提交任务</span></span><br><span class="line">        Long sum = submit.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"sum="</span>+sum+<span class="string">" 时间："</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Stream并行流 ()  (]</span></span><br><span class="line">        <span class="keyword">long</span> sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"sum="</span>+<span class="string">"时间："</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、异步回调"><a href="#六、异步回调" class="headerlink" title="六、异步回调"></a>六、异步回调</h3><blockquote>
<p><strong>什么是异步回调？</strong></p>
<p>对将来的某个事件的结果进行建模</p>
<p><img src="https://img-blog.csdnimg.cn/20200525110642109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<blockquote>
<p> 异步回调分两种</p>
</blockquote>
<p>1）无返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 无返回值的 runAsync 异步回调</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">// 创建异步任务：接收一个Runnable</span></span><br><span class="line">       CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//停留2s---模拟该任务执行2s时间</span></span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+<span class="string">"无返回值，异步线程体方法..."</span>);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 在主线程执行其他逻辑</span></span><br><span class="line">       System.out.println(<span class="string">"111"</span>);</span><br><span class="line"></span><br><span class="line">       future.get(); <span class="comment">//开启异步线程 等待获取阻塞执行结果</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">111</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">1</span>无返回值，异步线程体方法...</span><br></pre></td></tr></table></figure>

<p>2）有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//2 有返回值的 supplyAsync 异步回调</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">      	<span class="comment">// 创建异步任务：</span></span><br><span class="line">       <span class="comment">// 泛型是任务返回的结果类型</span></span><br><span class="line">       CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">           System.out.println(<span class="string">"业务逻辑..."</span>);</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+<span class="string">"有返回值，异步线程体方法...\n"</span>);</span><br><span class="line">           <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">           <span class="comment">// 正常执行，返回1024</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       Integer val = future.whenComplete((t, e) -&gt; &#123;   <span class="comment">// futrue正常执行 的结果</span></span><br><span class="line">           <span class="comment">// t,正常返回的结果 1024</span></span><br><span class="line">           <span class="comment">// e,异常信息</span></span><br><span class="line">           System.out.println(<span class="string">"完成业务逻辑...："</span>);</span><br><span class="line">           System.out.println(<span class="string">"t-&gt;"</span> + t);</span><br><span class="line">           System.out.println(<span class="string">"e-&gt;"</span> + e+<span class="string">"\n"</span>);</span><br><span class="line">       &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">"业务逻辑存在异常..."</span>);</span><br><span class="line">           System.out.println(<span class="string">"error Msg: "</span>+e.getMessage());  <span class="comment">// 异常执行返回的结果</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">       &#125;).get();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 返回结果【正确=1024    错误=500</span></span><br><span class="line">       System.out.println(val);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">业务逻辑...</span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">1</span>有返回值，异步线程体方法...</span><br><span class="line"></span><br><span class="line">完成业务逻辑...：</span><br><span class="line">t-&gt;<span class="keyword">null</span></span><br><span class="line">e-&gt;java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><br><span class="line"></span><br><span class="line">业务逻辑存在异常...</span><br><span class="line">error Msg: java.lang.ArithmeticException: / by zero</span><br><span class="line"><span class="number">500</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-JUC编程（3）</title>
    <url>/2020/05/25/Java-JUC%E7%BC%96%E7%A8%8B%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、Java内存模型"><a href="#一、Java内存模型" class="headerlink" title="一、Java内存模型"></a>一、Java内存模型</h3><blockquote>
<p>JMM：Java内存模型，不存在的东西，概念！约定！ </p>
</blockquote>
<p><strong>关于JMM的一些同步的约定</strong></p>
<p>1、线程加锁前，必须读取主存中的新值到工作内存中！ </p>
<p>2、线程解锁前，必须把共享变量立刻刷回主存。</p>
<p>3、加锁和解锁是同一把锁 </p>
<a id="more"></a>

<blockquote>
<p>关乎：线程、工作内存、主内存</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020052514240084.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p>
<ul>
<li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li><strong>unlock（解锁）</strong>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><strong>read（读取）</strong>：作用于主内存变量，把一个变量值<strong>从主内存传输到线程的工作内存</strong>中，以便随后的load动作使用</li>
<li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值<strong>放入工作内存的变量副本中。</strong></li>
<li><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>
<p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p>
<ul>
<li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>
</ul>
<h3 id="二、Volatile关键字"><a href="#二、Volatile关键字" class="headerlink" title="二、Volatile关键字"></a>二、Volatile关键字</h3><blockquote>
<p>3大特性：</p>
<ul>
<li>保证内存可见性</li>
<li>非原子性</li>
<li>禁止指令重排</li>
</ul>
</blockquote>
<h4 id="1）内存可见性"><a href="#1）内存可见性" class="headerlink" title="1）内存可见性"></a>1）内存可见性</h4><p><img src="https://img-blog.csdnimg.cn/20200525142426733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 理解JMM模型   Java内存模型</span></span><br><span class="line"><span class="comment"> * volatile: 验证内存可见性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-22 15:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJMM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加上volatile   可以保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保线程1启动</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在主线程中修改num,线程1不可见。所以无法停止</span></span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）非原子性"><a href="#2）非原子性" class="headerlink" title="2）非原子性"></a>2）非原子性</h4><blockquote>
<p>什么是原子性： 就是不可分，从头执行到尾，不能被其他线程同时执行。 </p>
<p>如何解决：使用原子类【本例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证：</span></span><br><span class="line"><span class="comment"> * volatile:不能保证原子性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  线程A在执行任务的时候，不能被打扰的，也不能被分割。要么同时成功，要么同时朱败。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-22 21:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用volatile不能保证原子性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子类解决</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger num2 = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1.加锁可以解决</span></span><br><span class="line">        <span class="comment">//num++;</span></span><br><span class="line"></span><br><span class="line">        num2.incrementAndGet();  <span class="comment">// +1操作  CAS</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 理论：20000   实际：main num: 17987</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">1000</span>; i1++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证上面的线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" num: "</span>+num2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**字节码反编译后：发现，其实num++存在3个操作，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  获取num---&gt; num++ ---&gt;设置num</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  所以：num++ 不是一个原子性操作</span></span><br><span class="line"><span class="comment"> *  多线程情况下，可能存在指令</span></span><br><span class="line"><span class="comment"> *  public static add() &#123; //()V</span></span><br><span class="line"><span class="comment"> *          L1 &#123;</span></span><br><span class="line"><span class="comment"> *              getstatic pers/xu/multithread/kuangshen/juc/volatile1/Test2.num:int</span></span><br><span class="line"><span class="comment"> *              iconst_1</span></span><br><span class="line"><span class="comment"> *              iadd</span></span><br><span class="line"><span class="comment"> *              putstatic pers/xu/multithread/kuangshen/juc/volatile1/Test2.num:int</span></span><br><span class="line"><span class="comment"> *          &#125;</span></span><br><span class="line"><span class="comment"> *          L2 &#123;</span></span><br><span class="line"><span class="comment"> *              return</span></span><br><span class="line"><span class="comment"> *          &#125;</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="3）禁止指令重排"><a href="#3）禁止指令重排" class="headerlink" title="3）禁止指令重排"></a>3）禁止指令重排</h4><blockquote>
<p>什么是指令重排：JVM可以对某些指令进行重新排序执行，</p>
<p>经典例子：单例模式–双重校验锁【懒汉式</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020052514245732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例---饿汉模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-22 22:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Res</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Res</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Res res = <span class="keyword">new</span> Res();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Res <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式:</span></span><br><span class="line"><span class="comment"> *    指令重排</span></span><br><span class="line"><span class="comment"> *    反射破坏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Res2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Res2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 使用volatile防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Res2 res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Res2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == res)&#123;</span><br><span class="line">            <span class="comment">// 多个线程进入，再判断是否持有锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Res2<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> == res)&#123;</span><br><span class="line">                    <span class="comment">// 不是一个个原子操作---可能出现指令重排</span></span><br><span class="line">                    <span class="comment">// 1.分配内存   2.初始化对象    2.将这个引用res指向这个对象</span></span><br><span class="line">                    <span class="comment">// 正常顺序：1-2-3     重排：1 3 2</span></span><br><span class="line">                    <span class="comment">// 这时候有可能一个线程进来判断res!=null,就把这个对象拿去用了。造成错误</span></span><br><span class="line">                    res = <span class="keyword">new</span> Res2();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举实现单例：</span></span><br><span class="line"><span class="comment"> *      说明：上面2种模式，都可以通过暴力反射获取第二个对象。破坏单例模式</span></span><br><span class="line"><span class="comment"> *      但枚举类不可被反射破坏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> Res3&#123;</span><br><span class="line">    SUMMER;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Res3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Res3.SUMMER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认构造函数：(String,int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、理解CAS"><a href="#三、理解CAS" class="headerlink" title="三、理解CAS"></a>三、理解CAS</h3><blockquote>
<p> <strong>CompareAndSwap</strong></p>
<p> 比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就 一直循环！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 理解CAS：比较并交换</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unsafe类：java无法直接操作内存，但可以调用c++.c++可以操作内存</span></span><br><span class="line"><span class="comment"> *          这个类相当于中间人的操作。可以调用这个类的方法操作内存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-23 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数：期望的值，更新的值</span></span><br><span class="line">        <span class="comment">// 期望、更新</span></span><br><span class="line">        <span class="comment">// public final boolean compareAndSet(int expect, int update)</span></span><br><span class="line">        <span class="comment">// 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        <span class="comment">// get()：获取当前值</span></span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// +1</span></span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是2020，就更新为2021</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>,<span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解析UnSafe类：</p>
</blockquote>
<blockquote>
<p>AtomicInteger类</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200525142523352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>AtomicInteger类     ——-&gt;compareAndSet()操作</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200525142536824.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200525142550858.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>AtomicInteger类     ——-&gt;getAndIncrement()</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200525142603513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200525142617539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>var5是原子对象中的值，主存中只有一个。</p>
<ul>
<li>线程获取value副本放入自己的工作内存，赋值给var5【这个var5就是该线程期望的值</li>
<li>然后将var5与内存中的value比较，相同则允许更新值。否则一直等待</li>
<li>上面也称为<strong>自旋锁</strong></li>
</ul>
</blockquote>
<blockquote>
<p>CAS ： 不断比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就 一直循环！</p>
</blockquote>
<p><strong>缺点：</strong><br>1、 循环会耗时<br>2、一次性只能保证一个共享变量的原子性</p>
<p>3、ABA问题【狸猫换太子</p>
<h3 id="四、原子引用解决ABA问题"><a href="#四、原子引用解决ABA问题" class="headerlink" title="四、原子引用解决ABA问题"></a>四、原子引用解决ABA问题</h3><h4 id="1）什么是ABA问题？"><a href="#1）什么是ABA问题？" class="headerlink" title="1）什么是ABA问题？"></a>1）什么是ABA问题？</h4><blockquote>
<p><strong>狸猫换太子</strong></p>
<p>2个小孩都发现了一个蛋糕，A小孩动作快，把蛋糕里面的水果拿了。但是B小孩并不知道蛋糕已经被动过了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 理解CAS：</span></span><br><span class="line"><span class="comment"> *  CAS ： ABA 问题（狸猫换太子）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-23 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数：期望的值，更新的值</span></span><br><span class="line">        <span class="comment">// public final boolean compareAndSet(int expect, int update)</span></span><br><span class="line">        <span class="comment">// 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ============== 捣乱的线程 ==================</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">        System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2021</span>,<span class="number">2020</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前线程并不知道改变了，所以依然执行了操作</span></span><br><span class="line">        <span class="comment">// 我们希望能够其他线程能 发现 value已经被动过了</span></span><br><span class="line">        <span class="comment">// ============== 期望的线程 ==================</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>,<span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">2021</span></span><br><span class="line">---------------</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">2020</span></span><br><span class="line">---------------不知道原子Integer已经被修改了。所以修改成功</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">2021</span></span><br></pre></td></tr></table></figure>

<h4 id="2）如何解决ABA？"><a href="#2）如何解决ABA？" class="headerlink" title="2）如何解决ABA？"></a>2）如何解决ABA？</h4><blockquote>
<p><strong>AtomicStampedReference</strong>：带版本号的原子引用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原子引用：</span></span><br><span class="line"><span class="comment"> * 解决ABA 问题（狸猫换太子）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 一旦原子对象被修改，就改变版本号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-23 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数：原子引用对象 ， 版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; reference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CAS  compareAndSet : 比较并交换！</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = reference.getStamp();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"A get stamp: "</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当前线程休息一下</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把原子对象修改为2</span></span><br><span class="line">            System.out.println(<span class="string">"A fix atomicObj :"</span>+reference.compareAndSet(<span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">                    reference.getStamp(), reference.getStamp() + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"A get stamp:---&gt;"</span> + reference.getStamp()+<span class="string">"    ---atomicObj: "</span>+reference.getReference());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 再把修改为2的值  修改成1</span></span><br><span class="line">            <span class="comment">// ------&gt;这个时候b线程就知道原子对象被修改了。因为版本号不一样</span></span><br><span class="line">            System.out.println(<span class="string">"A fix atomicObj :"</span>+reference.compareAndSet(<span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">                    reference.getStamp(),</span><br><span class="line">                    reference.getStamp() + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"A get stamp:---&gt;"</span> + reference.getStamp()+<span class="string">"    ---&gt;atomicObj: "</span>+reference.getReference());</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 乐观锁的原理相同！</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = reference.getStamp(); <span class="comment">// 获得版本号</span></span><br><span class="line">            System.out.println(<span class="string">"B get stamp: "</span> + stamp);</span><br><span class="line">            System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 休息更长，确保a开始操作原子对象</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 期望的版本号（第一次从内存获取的）与实际版本号不一致，修改原子引用对象失败</span></span><br><span class="line">            System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"B fix atomicObj :"</span>+reference.compareAndSet(<span class="number">1</span>, <span class="number">6</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">"B get stamp:---&gt;"</span> + reference.getStamp()+<span class="string">"    ---&gt;atomicObj: "</span>+reference.getReference());</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A get stamp: <span class="number">1</span></span><br><span class="line">B get stamp: <span class="number">1</span></span><br><span class="line">-----------------</span><br><span class="line">A fix atomicObj :<span class="keyword">true</span></span><br><span class="line">A get stamp:---&gt;<span class="number">2</span>    ---atomicObj: <span class="number">2</span></span><br><span class="line">A fix atomicObj :<span class="keyword">true</span></span><br><span class="line">A get stamp:---&gt;<span class="number">3</span>    ---&gt;atomicObj: <span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line">B fix atomicObj :<span class="keyword">false</span></span><br><span class="line">B get stamp:---&gt;<span class="number">3</span>    ---&gt;atomicObj: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="五、可重入锁、自旋锁"><a href="#五、可重入锁、自旋锁" class="headerlink" title="五、可重入锁、自旋锁"></a>五、可重入锁、自旋锁</h3><h4 id="1）可重入锁"><a href="#1）可重入锁" class="headerlink" title="1）可重入锁"></a>1）可重入锁</h4><blockquote>
<p> 线程可以进入任何一个它已经拥有的锁-所同步着的代码块。 </p>
</blockquote>
<ol>
<li><code>synchronized</code>可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；</li>
<li><code>ReentrantLock</code>也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。</li>
<li><code>synchronized</code>不可响应中断，一个线程获取不到锁就一直等着；<code>ReentrantLock</code>可以响应中断。</li>
<li>使用<code>Lock</code>锁必须要成对使用，否则–&gt;死锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();  <span class="comment">// 获取lock1</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" 发短信...."</span>);</span><br><span class="line">            call();   <span class="comment">// 获取call()和sms()使用的是同一把锁，可以重复获取</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();   <span class="comment">//释放lock1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" 打电话...."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A 发短信....</span><br><span class="line">A 打电话....</span><br><span class="line">B 发短信....</span><br><span class="line">B 打电话....</span><br></pre></td></tr></table></figure>

<h4 id="2）自旋锁"><a href="#2）自旋锁" class="headerlink" title="2）自旋锁"></a>2）自旋锁</h4><blockquote>
<p>使用<strong>原子引用</strong>自定义一个自旋锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.xu.multithread.kuangshen.juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋锁</span></span><br><span class="line"><span class="comment"> *      原子引用：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-23 10:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int --&gt;默认0</span></span><br><span class="line">    <span class="comment">// Thread --&gt;null</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;进入lock()"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自旋锁</span></span><br><span class="line">        <span class="comment">// A来之后，期望null--&gt;修改为thread---&gt;进行业务操作</span></span><br><span class="line">        <span class="comment">// B来之后，期望null,但是被已修改为thread。所以一直等待。直到A释放锁---&gt;重新改为null</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>,thread))&#123;</span><br><span class="line">           <span class="comment">// 原子引用被修改--一直等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;释放锁"</span>);</span><br><span class="line">        <span class="comment">// 将原子引用改回即可</span></span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用自定义自旋锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.xu.multithread.kuangshen.juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-23 10:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lock lock = new ReentrantLock();</span></span><br><span class="line">        <span class="comment">//lock.lock();</span></span><br><span class="line">        <span class="comment">//lock.unlock();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义自旋锁</span></span><br><span class="line">        SpinLockDemo lock = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            lock.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"获取锁 执行业务逻辑A..."</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.myUnlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保A拿到锁</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            lock.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"获取锁 执行业务逻辑B..."</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.myUnlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A--&gt;进入lock()</span><br><span class="line">获取锁 执行业务逻辑A...</span><br><span class="line">B--&gt;进入lock()</span><br><span class="line">A--&gt;释放锁</span><br><span class="line">获取锁 执行业务逻辑B...</span><br><span class="line">B--&gt;释放锁</span><br></pre></td></tr></table></figure>

<h3 id="六、死锁排查"><a href="#六、死锁排查" class="headerlink" title="六、死锁排查"></a>六、死锁排查</h3><blockquote>
<p>两个命令：</p>
<ul>
<li><code>jps -l</code> ：查看进程号</li>
<li><code>jstack 进程号</code>：查看对应线程的堆栈信息</li>
</ul>
</blockquote>
<h4 id="1）死锁演示"><a href="#1）死锁演示" class="headerlink" title="1）死锁演示"></a>1）死锁演示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试死锁</span></span><br><span class="line"><span class="comment"> *      多个线程互相拥有对方需要的资源，形成僵持</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-16 22:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lock1;</span><br><span class="line">    <span class="keyword">private</span> String lock2;</span><br><span class="line"></span><br><span class="line">    Player(String lock1, String lock2, String name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.lock1 = lock1;</span><br><span class="line">        <span class="keyword">this</span>.lock2 = lock2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//确保2线程都启动</span></span><br><span class="line">            deadLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死锁：持有锁，并想获得对方的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" have "</span> + lock1+<span class="string">"-----&gt;need "</span>+lock2);</span><br><span class="line">            <span class="comment">//保证2线程都启动</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" get "</span> + lock2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String lock1 = <span class="string">"lock-A"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String lock2 = <span class="string">"lock-B"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Player a = <span class="keyword">new</span> Player(lock1, lock2, <span class="string">"T1"</span>);</span><br><span class="line">        Player b = <span class="keyword">new</span> Player(lock2, lock1, <span class="string">"T2"</span>);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）如何排查"><a href="#2）如何排查" class="headerlink" title="2）如何排查"></a>2）如何排查</h4><ol>
<li>在命令行终端使用<code>jps -l</code>查看进程号</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200525142704664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol start="2">
<li>使用<code>jstack 进程号</code>查看堆栈信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstack 59356</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2020052514282230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
</search>
