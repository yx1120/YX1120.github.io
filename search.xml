<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Travel Log-1</title>
    <url>/2020/05/19/travel/</url>
    <content><![CDATA[<p>不急不急</p>
]]></content>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk1.7 HashMap源码</title>
    <url>/2020/05/20/jdk1.7%20HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<blockquote>
<p>1.7 HashMap底层使用的是（Entry）数组+链表实现</p>
<p>线程不安全，在多个线程进行插入操作时，可能会出现死循环，数据覆盖问题</p>
<p>1.8 中HashMap底层使用的是（Node）数组+链表+红黑树实现，不会出现死循环，但仍有数据覆盖问题</p>
<p>需要线程安全的话，建议使用ConcurrentHashMap</p>
</blockquote>
<img src='https://pic.downk.cc/item/5ec486b7c2a9a83be5103d16.png'>

<h3 id="1）HashMap中的字段"><a href="#1）HashMap中的字段" class="headerlink" title="1）HashMap中的字段"></a>1）HashMap中的字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//默认初始容量=16，必须为2的幂</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">   <span class="comment">//映射最大容量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">   <span class="comment">//构造函数未指定负载因子时，使用的默认负载因子：0.75</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 散列表，长度始终是2的幂。</span></span><br><span class="line"><span class="comment">    * 为什么不是向HashTable使用一个素数呢？为了方便后面的扩容操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//hash表中存储的实际元素个数</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阈值 = hash表容器capacity * 负载因子loadfactor</span></span><br><span class="line"><span class="comment"> * size &gt; 阈值，就进行扩容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">int</span> threshold;</span><br><span class="line">  	<span class="comment">// 手动指定的负载因子</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">   <span class="comment">// 此字段用于使HashMap的Collection-view上的迭代器快速失败</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">   <span class="comment">// 默认阈值，可以使用上面的 threshold覆盖该值</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果值为true，则对字符串键执行备用哈希处理，以减少由于哈希码计算能力较弱而导致的冲突发生率。</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">boolean</span> useAltHashing;</span><br></pre></td></tr></table></figure>

<h3 id="2）节点类Entry"><a href="#2）节点类Entry" class="headerlink" title="2）节点类Entry"></a>2）节点类Entry</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates new entry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）构造函数"><a href="#2）构造函数" class="headerlink" title="2）构造函数"></a>2）构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的容量和负载因子初始化HashMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//参数有效判断</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">       <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 确保初始容量是2的幂，比如指定initialCapacity=12，经过这里后，capacity=16</span></span><br><span class="line">       <span class="comment">// 即：找到不小于“指定容量”的最小2次幂</span></span><br><span class="line">       <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">           capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//初始化负载因子、计算阈值</span></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">       table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">       </span><br><span class="line">       useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">               (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">       init();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定初始容量</span></span><br><span class="line"><span class="comment">    * 使用默认的负载因子0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 无参构造</span></span><br><span class="line"><span class="comment">    * 使用默认的初始容量16 和负载因子0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3）添加元素"><a href="#3）添加元素" class="headerlink" title="3）添加元素"></a>3）添加元素</h3><blockquote>
<p>总体流程：</p>
<ol>
<li>计算散列位置，判断是否有该key,如果有，则使用新值覆盖旧值</li>
<li>没有的话，进入addEntry()<ol>
<li>判断当前元素个数是否大于阈值，大于的话<ul>
<li>进行扩容resize()，2倍扩容hash表长</li>
<li>然后将元素重新映射到新表上</li>
</ul>
</li>
<li>小于当前阈值，进入createEntry()，使用头插法插入元素</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="gt-1-put-：入口"><a href="#gt-1-put-：入口" class="headerlink" title="-&gt;1 put()：入口"></a>-&gt;1 put()：入口</h4><blockquote>
<p>作用：</p>
<ul>
<li><p>如果key已经存在，则新值取代旧值。</p>
</li>
<li><p>不存在则进入addEntry()方法</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素，如果key已经存在，则新值取代旧值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="comment">// 计算插入的索引</span></span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="comment">// 在以table[i]为头结点的链表上寻找是否已经有该key,如果有，用新值替代旧值</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="comment">//返回旧值</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">//添加Entry节点</span></span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算哈希码h的在散列表(Entry&lt;K,V&gt; [] table)上的索引</span></span><br><span class="line"><span class="comment">    * 		h: key的hashCode</span></span><br><span class="line"><span class="comment">    * 		length: table的表长</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算key的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (useAltHashing) &#123;</span><br><span class="line">           <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">               <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">           &#125;</span><br><span class="line">           h = hashSeed;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">       <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">       <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">       h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">       <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-2-addEntry"><a href="#gt-2-addEntry" class="headerlink" title="-&gt;2 addEntry()"></a>-&gt;2 addEntry()</h4><blockquote>
<p>作用：</p>
<ul>
<li>判断size是否大于阈值，大于则进行扩容resize()，并重新计算key的散列位置</li>
<li>小于则进入createEntry() 使用头插法插入元素</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素操作-2</span></span><br><span class="line"><span class="comment"> * 		hash: key的hash值</span></span><br><span class="line"><span class="comment"> * 		bucketIndex:插入的散列表索引位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//如果当前元素个数 size&gt;= 阈值 ，同时插入的位置已经有元素了---&gt;扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            <span class="comment">//扩容操作，2倍扩容。扩的是散列表的长度</span></span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            <span class="comment">//重新计算key的hash值</span></span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//重新计算散列位置</span></span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//最终的插入操作</span></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-3-resize-：扩容操作"><a href="#gt-3-resize-：扩容操作" class="headerlink" title="-&gt;3 resize()：扩容操作"></a>-&gt;3 resize()：扩容操作</h4><blockquote>
<p>作用：</p>
<ul>
<li>创建一个新的hash表（Entry数组），进入<code>transfer()</code>，将原来的hash表中元素散列到新hash表</li>
<li>重新计算阈值</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容操作：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    	<span class="comment">// 如果老散列表长度已经=HashMap最大容量【2^30】</span></span><br><span class="line">    	<span class="comment">// --&gt;修改阈值为Integer的最大值【2^31-1】，不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// 根据新散列表长创建一个新的散列表</span></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;</span><br><span class="line">    	<span class="comment">//数据转移到新表上</span></span><br><span class="line">        transfer(newTable, rehash);</span><br><span class="line">        table = newTable;</span><br><span class="line">    	<span class="comment">//计算新阈值</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前表中元素散列到新表上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="comment">//e：每一个链表头</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                <span class="comment">// 先保留头结点下一元素</span></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">               	<span class="comment">// 计算新的散列位置</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                <span class="comment">// 取旧表的表头使用头插法再次插入新表</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-4-createEntry-：最终的插入操作"><a href="#gt-4-createEntry-：最终的插入操作" class="headerlink" title="-&gt;4 createEntry()：最终的插入操作"></a>-&gt;4 createEntry()：最终的插入操作</h4><blockquote>
<p>作用：</p>
<ul>
<li>使用头插法插入元素</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//采用的是头插法，</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//先保留老头结点，后面会连上</span></span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="4）获取元素"><a href="#4）获取元素" class="headerlink" title="4）获取元素"></a>4）获取元素</h3><h4 id="gt-1-get-：入口"><a href="#gt-1-get-：入口" class="headerlink" title="-&gt;1 get()：入口"></a>-&gt;1 get()：入口</h4><blockquote>
<p>作用：</p>
<ul>
<li>如果键为空，则返回空键对应的值或null</li>
<li>不为空，进入getEntry()</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="–-gt-getEntry-：获取key对应的Entry节点"><a href="#–-gt-getEntry-：获取key对应的Entry节点" class="headerlink" title="–&gt; getEntry()：获取key对应的Entry节点"></a>–&gt; getEntry()：获取key对应的Entry节点</h4><blockquote>
<p>作用：</p>
<ul>
<li>根据key计算散列索引，然后判断该索引对应的链表是否含有key</li>
<li>有则返回key对应的节点，无返回null</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>二分搜索树</title>
    <url>/2020/05/20/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h4 id="一、特点"><a href="#一、特点" class="headerlink" title="一、特点"></a>一、特点</h4><ol>
<li>二分搜索树是一颗二叉树</li>
<li>二分搜素树的每一个节点的值都大于其左子树所有节点的值，小于右子树所有节点的值<img src="https://img-blog.csdnimg.cn/20200421172624493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h4 id="二、底层维护"><a href="#二、底层维护" class="headerlink" title="二、底层维护"></a>二、底层维护</h4><ul>
<li><p>root ：树根节点</p>
</li>
<li><p>size ：树中元素个数</p>
</li>
</ul>
<h4 id="三、注意"><a href="#三、注意" class="headerlink" title="三、注意"></a>三、注意</h4><p>树中的节点必须具有可比较性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分搜索树：</span></span><br><span class="line"><span class="comment"> * 特点：1.每一个节点都比左孩子大，比右孩子小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-04-20 15:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root; <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;  <span class="comment">//元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//...具体操作在下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、搜索二叉树的基本操作"><a href="#四、搜索二叉树的基本操作" class="headerlink" title="四、搜索二叉树的基本操作"></a>四、搜索二叉树的基本操作</h4><ol>
<li>向以node为根节点的树中添加元素e，并返回根节点。【递归算法】</li>
</ol>
<blockquote>
<p>注：（除node为null外）元素e最后会和树中一个叶子节点的（左或右）孩子进行比较。叶子节点左右孩子都为空，进入比较后会返回一个的新节点，就是叶子节点的孩子。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           size++;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">       &#125;</span><br><span class="line">   	<span class="comment">//e&lt;当前节点，进入左子树继续比较。把node当做叶子节点</span></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//插入后node.left 可能会改变，需要重新接受</span></span><br><span class="line">           node.left = add(node.left, e);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//e&gt;当前节点，进入右子树</span></span><br><span class="line">           node.right = add(node.right, e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//不处理相同的情况</span></span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看以node为根节点的二分搜索树是否包含元素e</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> contains(node.left, e);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> contains(node.right, e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>前序遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.print(<span class="string">"#-&gt;"</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.print(node.e + <span class="string">"-&gt;"</span>);</span><br><span class="line">       preOrder(node.left);</span><br><span class="line">       preOrder(node.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>非递归前序遍历【<strong>借助栈</strong></li>
</ol>
<blockquote>
<p>先把根节点压入栈，【1.然后出栈访问。2. 再把左右孩子（非空）压入栈。–&gt;递归进入第一步】</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助栈实现前序非递归遍历</span></span><br><span class="line">   <span class="comment">//深度优先遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder22</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="comment">//1.把根节点压入栈</span></span><br><span class="line">       stack.push(root);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           Node pop = stack.pop();</span><br><span class="line">           System.out.print(pop.e + <span class="string">"-&gt;"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//压入左右孩子，因为使用的是栈。所以先压入右孩子，再压左孩子</span></span><br><span class="line">           <span class="comment">//那么左孩子就先出栈</span></span><br><span class="line">           <span class="keyword">if</span> (pop.right != <span class="keyword">null</span>)</span><br><span class="line">               stack.push(pop.right);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (pop.left != <span class="keyword">null</span>)</span><br><span class="line">               stack.push(pop.left);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>后序遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tailOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.print(<span class="string">"#-&gt;"</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       tailOrder(node.left);</span><br><span class="line">       tailOrder(node.right);</span><br><span class="line">       System.out.print(node.e + <span class="string">"-&gt;"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>中序遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">middleOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.print(<span class="string">"#-&gt;"</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       middleOrder(node.left);</span><br><span class="line">       System.out.print(node.e + <span class="string">"-&gt;"</span>);</span><br><span class="line">       middleOrder(node.right);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>层次遍历【<strong>借助队列</strong></li>
</ol>
<blockquote>
<p>先把根节点入队，【1.出队访问，2.再把左右孩子入队—&gt;递归-&gt;1】</p>
<p><img src="https://img-blog.csdnimg.cn/20200421172701545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层次遍历，借助队列</span></span><br><span class="line">   <span class="comment">//也叫做广度优先遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       <span class="comment">//1.把根节点压入栈</span></span><br><span class="line">       queue.add(root);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//输出这一层（栈内）所有节点</span></span><br><span class="line">       <span class="comment">//同时把这一层的所有节点的子孩子压入栈</span></span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">           Node pop = queue.remove();</span><br><span class="line">           System.out.print(pop.e + <span class="string">"-&gt;"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (pop.left != <span class="keyword">null</span>)</span><br><span class="line">               queue.add(pop.left);</span><br><span class="line">           <span class="keyword">if</span> (pop.right != <span class="keyword">null</span>)</span><br><span class="line">               queue.add(pop.right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>获取二分搜索树的最大最小值节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最小节点</span></span><br><span class="line"><span class="comment">//不断往左子树找，最后没有左子树的那个节点，就是最小节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">miniNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> miniNode(node.left);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大节点：同理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maxNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node.right == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       <span class="keyword">return</span> maxNode(node.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ol start="8">
<li>删除二分搜索树最小值，最大值的节点</li>
</ol>
<blockquote>
<ul>
<li>删除最小值节点：【不断往左子树寻找<ul>
<li>node.left = null ，找到最小节点   </li>
<li>该节点的右子树不一定为空，所以将右子树第一个节点返回作为新的根节点</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200505162228303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<blockquote>
<ul>
<li>同理：删除最大值节点：【不断往右子树寻找<ul>
<li>node.right = null , 即为最大值节点</li>
<li>该节点左子树不一定为空，所以将左子树第一个节点返回作为根节点</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// node.left==null 即：如果该节点为最小节点</span></span><br><span class="line">       <span class="comment">// 则返回该节点右子树的第一个节点</span></span><br><span class="line">       <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果左子树为空，则该节点右子树第一个为最大的节点</span></span><br><span class="line">           Node retNode = node.right;</span><br><span class="line">           <span class="comment">//断开与右子树的关系</span></span><br><span class="line">           node.right = <span class="keyword">null</span>;</span><br><span class="line">           size--;</span><br><span class="line">           <span class="comment">//返回新根节点</span></span><br><span class="line">           <span class="keyword">return</span> retNode;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//该节点不是最小节点，继续进入左子树。</span></span><br><span class="line">       <span class="comment">//用node.left 接收删除后的新根节点--&gt;A.left = C</span></span><br><span class="line">       node.left = removeMin(node.left);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回删除节点后新的二分搜索树的根</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// node.right==null    即：当前节点为最大节点</span></span><br><span class="line">       <span class="comment">// 返回左子树第一个节点</span></span><br><span class="line">       <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果右子树为空，则左子树第一个为最大的节点</span></span><br><span class="line">           Node retNode = node.left;</span><br><span class="line">           <span class="comment">//断开与左子树的关系</span></span><br><span class="line">           node.left = <span class="keyword">null</span>;</span><br><span class="line">           size--;</span><br><span class="line">           <span class="comment">//返回新根节点</span></span><br><span class="line">           <span class="keyword">return</span> retNode;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//当前节点不是最大节点,继续进入右子树寻找</span></span><br><span class="line">       node.right = removeMax(node.right);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>删除以node为根的二分搜索树中值为e的节点，并返回删除后的根节点。【递归算法</li>
</ol>
<blockquote>
<p>“待删除节点”有3种情况：</p>
<ul>
<li>左子树为空  =&gt;【删除最小节点</li>
<li>右子树为空  =&gt;【删除最大节点</li>
<li>左右子树都不为空【==如下图，删除d节点==<ul>
<li>1 .找到待删除节点 <strong>d</strong> 的右子树的最小节点 <strong>s</strong></li>
<li>2 .用 <strong>s</strong> 替代 <strong>d</strong> 的位置<ul>
<li><strong>s</strong> = miniNode(<strong>d</strong>.right);</li>
<li><strong>s</strong>.right = removeMini(<strong>d</strong>.right);</li>
<li><strong>s</strong>.left = <strong>d</strong>.left</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注：删除节点后依然维持着二分搜索树的性质</p>
<p><img src="https://img-blog.csdnimg.cn/20200505162146245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除值为e的节点，返回新的根节点 	</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//e&lt;当前节点，进入左子树</span></span><br><span class="line">           node.left = remove(node.left, e);</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//e&gt;当前节点，进入右子树</span></span><br><span class="line">           node.right = remove(node.right, e);</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//找到待删除节点e</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment">//待删除节点左子树为空</span></span><br><span class="line">           <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">               Node rightNode = node.right;</span><br><span class="line">               <span class="comment">//断开node和右子树的连接</span></span><br><span class="line">               node.right = <span class="keyword">null</span>;</span><br><span class="line">               size--;</span><br><span class="line">               <span class="comment">//返回删除节点后的（局部）根节点</span></span><br><span class="line">               <span class="keyword">return</span> rightNode;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//待删除节点右子树为空</span></span><br><span class="line">           <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">               Node leftNode = node.left;</span><br><span class="line">               <span class="comment">//断开node和右子树的连接</span></span><br><span class="line">               node.left = <span class="keyword">null</span>;</span><br><span class="line">               size--;</span><br><span class="line">               <span class="comment">//返回删除节点后的（局部）根节点</span></span><br><span class="line">               <span class="keyword">return</span> leftNode;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//待删除节点的左右子树均不为空</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//1.寻找“待删除节点”右子树的最小节点</span></span><br><span class="line">           Node rightMiniNode = miniNode(node.right);</span><br><span class="line">           <span class="comment">//2.删除待删节点的右子树的最小值并把新树的作为 “替代节点” 的右子树</span></span><br><span class="line">           rightMiniNode.right = removeMin(node.right);</span><br><span class="line">           <span class="comment">//3.把待删除节点的左子树接到 “替代节点”的左子树</span></span><br><span class="line">           rightMiniNode.left = node.left;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.将删除的节点断开联系</span></span><br><span class="line">           node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">return</span> rightMiniNode;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
</search>
