<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Travel Log</title>
    <url>/2020/05/19/travel/</url>
    <content><![CDATA[<h3 id="what-do-you-want"><a href="#what-do-you-want" class="headerlink" title="what do you want"></a>what do you want</h3><a id="more"></a>]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk1.7 HashMap源码</title>
    <url>/2020/05/20/jdk1.7%20HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<blockquote>
<p>1.7 HashMap底层使用的是（Entry）数组+链表实现</p>
<p>线程不安全，在多个线程进行插入操作时，可能会出现死循环，数据覆盖问题</p>
<p>1.8 中HashMap底层使用的是（Node）数组+链表+红黑树实现，不会出现死循环，但仍有数据覆盖问题</p>
<p>需要线程安全的话，建议使用ConcurrentHashMap</p>
</blockquote>
<img src='https://pic.downk.cc/item/5ec486b7c2a9a83be5103d16.png'>

<a id="more"></a>

<h3 id="1）HashMap中的字段"><a href="#1）HashMap中的字段" class="headerlink" title="1）HashMap中的字段"></a>1）HashMap中的字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//默认初始容量=16，必须为2的幂</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">   <span class="comment">//映射最大容量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">   <span class="comment">//构造函数未指定负载因子时，使用的默认负载因子：0.75</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 散列表，长度始终是2的幂。</span></span><br><span class="line"><span class="comment">    * 为什么不是向HashTable使用一个素数呢？为了方便后面的扩容操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//hash表中存储的实际元素个数</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阈值 = hash表容器capacity * 负载因子loadfactor</span></span><br><span class="line"><span class="comment"> * size &gt; 阈值，就进行扩容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">int</span> threshold;</span><br><span class="line">  	<span class="comment">// 手动指定的负载因子</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">   <span class="comment">// 此字段用于使HashMap的Collection-view上的迭代器快速失败</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">   <span class="comment">// 默认阈值，可以使用上面的 threshold覆盖该值</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果值为true，则对字符串键执行备用哈希处理，以减少由于哈希码计算能力较弱而导致的冲突发生率。</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">boolean</span> useAltHashing;</span><br></pre></td></tr></table></figure>

<h3 id="2）节点类Entry"><a href="#2）节点类Entry" class="headerlink" title="2）节点类Entry"></a>2）节点类Entry</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates new entry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）构造函数"><a href="#2）构造函数" class="headerlink" title="2）构造函数"></a>2）构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的容量和负载因子初始化HashMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//参数有效判断</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">       <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 确保初始容量是2的幂，比如指定initialCapacity=12，经过这里后，capacity=16</span></span><br><span class="line">       <span class="comment">// 即：找到不小于“指定容量”的最小2次幂</span></span><br><span class="line">       <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">           capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//初始化负载因子、计算阈值</span></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">       table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">       </span><br><span class="line">       useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">               (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">       init();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定初始容量</span></span><br><span class="line"><span class="comment">    * 使用默认的负载因子0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 无参构造</span></span><br><span class="line"><span class="comment">    * 使用默认的初始容量16 和负载因子0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3）添加元素"><a href="#3）添加元素" class="headerlink" title="3）添加元素"></a>3）添加元素</h3><blockquote>
<p>总体流程：</p>
<ol>
<li>计算散列位置，判断是否有该key,如果有，则使用新值覆盖旧值</li>
<li>没有的话，进入addEntry()<ol>
<li>判断当前元素个数是否大于阈值，大于的话<ul>
<li>进行扩容resize()，2倍扩容hash表长</li>
<li>然后将元素重新映射到新表上</li>
</ul>
</li>
<li>小于当前阈值，进入createEntry()，使用头插法插入元素</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="gt-1-put-：入口"><a href="#gt-1-put-：入口" class="headerlink" title="-&gt;1 put()：入口"></a>-&gt;1 put()：入口</h4><blockquote>
<p>作用：</p>
<ul>
<li><p>如果key已经存在，则新值取代旧值。</p>
</li>
<li><p>不存在则进入addEntry()方法</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素，如果key已经存在，则新值取代旧值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="comment">// 计算插入的索引</span></span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="comment">// 在以table[i]为头结点的链表上寻找是否已经有该key,如果有，用新值替代旧值</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="comment">//返回旧值</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">//添加Entry节点</span></span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算哈希码h的在散列表(Entry&lt;K,V&gt; [] table)上的索引</span></span><br><span class="line"><span class="comment">    * 		h: key的hashCode</span></span><br><span class="line"><span class="comment">    * 		length: table的表长</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算key的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (useAltHashing) &#123;</span><br><span class="line">           <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">               <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">           &#125;</span><br><span class="line">           h = hashSeed;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">       <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">       <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">       h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">       <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-2-addEntry"><a href="#gt-2-addEntry" class="headerlink" title="-&gt;2 addEntry()"></a>-&gt;2 addEntry()</h4><blockquote>
<p>作用：</p>
<ul>
<li>判断size是否大于阈值，大于则进行扩容resize()，并重新计算key的散列位置</li>
<li>小于则进入createEntry() 使用头插法插入元素</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素操作-2</span></span><br><span class="line"><span class="comment"> * 		hash: key的hash值</span></span><br><span class="line"><span class="comment"> * 		bucketIndex:插入的散列表索引位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//如果当前元素个数 size&gt;= 阈值 ，同时插入的位置已经有元素了---&gt;扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            <span class="comment">//扩容操作，2倍扩容。扩的是散列表的长度</span></span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            <span class="comment">//重新计算key的hash值</span></span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//重新计算散列位置</span></span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//最终的插入操作</span></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-3-resize-：扩容操作"><a href="#gt-3-resize-：扩容操作" class="headerlink" title="-&gt;3 resize()：扩容操作"></a>-&gt;3 resize()：扩容操作</h4><blockquote>
<p>作用：</p>
<ul>
<li>创建一个新的hash表（Entry数组），进入<code>transfer()</code>，将原来的hash表中元素散列到新hash表</li>
<li>重新计算阈值</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容操作：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    	<span class="comment">// 如果老散列表长度已经=HashMap最大容量【2^30】</span></span><br><span class="line">    	<span class="comment">// --&gt;修改阈值为Integer的最大值【2^31-1】，不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// 根据新散列表长创建一个新的散列表</span></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;</span><br><span class="line">    	<span class="comment">//数据转移到新表上</span></span><br><span class="line">        transfer(newTable, rehash);</span><br><span class="line">        table = newTable;</span><br><span class="line">    	<span class="comment">//计算新阈值</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前表中元素散列到新表上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="comment">//e：每一个链表头</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                <span class="comment">// 先保留头结点下一元素</span></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">               	<span class="comment">// 计算新的散列位置</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                <span class="comment">// 取旧表的表头使用头插法再次插入新表</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-4-createEntry-：最终的插入操作"><a href="#gt-4-createEntry-：最终的插入操作" class="headerlink" title="-&gt;4 createEntry()：最终的插入操作"></a>-&gt;4 createEntry()：最终的插入操作</h4><blockquote>
<p>作用：</p>
<ul>
<li>使用头插法插入元素</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//采用的是头插法，</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//先保留老头结点，后面会连上</span></span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="4）获取元素"><a href="#4）获取元素" class="headerlink" title="4）获取元素"></a>4）获取元素</h3><h4 id="gt-1-get-：入口"><a href="#gt-1-get-：入口" class="headerlink" title="-&gt;1 get()：入口"></a>-&gt;1 get()：入口</h4><blockquote>
<p>作用：</p>
<ul>
<li>如果键为空，则返回空键对应的值或null</li>
<li>不为空，进入getEntry()</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="–-gt-getEntry-：获取key对应的Entry节点"><a href="#–-gt-getEntry-：获取key对应的Entry节点" class="headerlink" title="–&gt; getEntry()：获取key对应的Entry节点"></a>–&gt; getEntry()：获取key对应的Entry节点</h4><blockquote>
<p>作用：</p>
<ul>
<li>根据key计算散列索引，然后判断该索引对应的链表是否含有key</li>
<li>有则返回key对应的节点，无返回null</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>二分搜索树</title>
    <url>/2020/05/20/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h4 id="一、特点"><a href="#一、特点" class="headerlink" title="一、特点"></a>一、特点</h4><ol>
<li>二分搜索树是一颗二叉树</li>
<li>二分搜素树的每一个节点的值都大于其左子树所有节点的值，小于右子树所有节点的值<img src="https://img-blog.csdnimg.cn/20200421172624493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<a id="more"></a>

<h4 id="二、底层维护"><a href="#二、底层维护" class="headerlink" title="二、底层维护"></a>二、底层维护</h4><ul>
<li><p>root ：树根节点</p>
</li>
<li><p>size ：树中元素个数</p>
</li>
</ul>
<h4 id="三、注意"><a href="#三、注意" class="headerlink" title="三、注意"></a>三、注意</h4><p>树中的节点必须具有可比较性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分搜索树：</span></span><br><span class="line"><span class="comment"> * 特点：1.每一个节点都比左孩子大，比右孩子小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-04-20 15:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root; <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;  <span class="comment">//元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//...具体操作在下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、搜索二叉树的基本操作"><a href="#四、搜索二叉树的基本操作" class="headerlink" title="四、搜索二叉树的基本操作"></a>四、搜索二叉树的基本操作</h4><ol>
<li>向以node为根节点的树中添加元素e，并返回根节点。【递归算法】</li>
</ol>
<blockquote>
<p>注：（除node为null外）元素e最后会和树中一个叶子节点的（左或右）孩子进行比较。叶子节点左右孩子都为空，进入比较后会返回一个的新节点，就是叶子节点的孩子。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           size++;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">       &#125;</span><br><span class="line">   	<span class="comment">//e&lt;当前节点，进入左子树继续比较。把node当做叶子节点</span></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//插入后node.left 可能会改变，需要重新接受</span></span><br><span class="line">           node.left = add(node.left, e);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//e&gt;当前节点，进入右子树</span></span><br><span class="line">           node.right = add(node.right, e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//不处理相同的情况</span></span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看以node为根节点的二分搜索树是否包含元素e</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> contains(node.left, e);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> contains(node.right, e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>前序遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.print(<span class="string">"#-&gt;"</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.print(node.e + <span class="string">"-&gt;"</span>);</span><br><span class="line">       preOrder(node.left);</span><br><span class="line">       preOrder(node.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>非递归前序遍历【<strong>借助栈</strong></li>
</ol>
<blockquote>
<p>先把根节点压入栈，【1.然后出栈访问。2. 再把左右孩子（非空）压入栈。–&gt;递归进入第一步】</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助栈实现前序非递归遍历</span></span><br><span class="line">   <span class="comment">//深度优先遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder22</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="comment">//1.把根节点压入栈</span></span><br><span class="line">       stack.push(root);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           Node pop = stack.pop();</span><br><span class="line">           System.out.print(pop.e + <span class="string">"-&gt;"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//压入左右孩子，因为使用的是栈。所以先压入右孩子，再压左孩子</span></span><br><span class="line">           <span class="comment">//那么左孩子就先出栈</span></span><br><span class="line">           <span class="keyword">if</span> (pop.right != <span class="keyword">null</span>)</span><br><span class="line">               stack.push(pop.right);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (pop.left != <span class="keyword">null</span>)</span><br><span class="line">               stack.push(pop.left);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>后序遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tailOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.print(<span class="string">"#-&gt;"</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       tailOrder(node.left);</span><br><span class="line">       tailOrder(node.right);</span><br><span class="line">       System.out.print(node.e + <span class="string">"-&gt;"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>中序遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">middleOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           System.out.print(<span class="string">"#-&gt;"</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       middleOrder(node.left);</span><br><span class="line">       System.out.print(node.e + <span class="string">"-&gt;"</span>);</span><br><span class="line">       middleOrder(node.right);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>层次遍历【<strong>借助队列</strong></li>
</ol>
<blockquote>
<p>先把根节点入队，【1.出队访问，2.再把左右孩子入队—&gt;递归-&gt;1】</p>
<p><img src="https://img-blog.csdnimg.cn/20200421172701545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层次遍历，借助队列</span></span><br><span class="line">   <span class="comment">//也叫做广度优先遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       <span class="comment">//1.把根节点压入栈</span></span><br><span class="line">       queue.add(root);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//输出这一层（栈内）所有节点</span></span><br><span class="line">       <span class="comment">//同时把这一层的所有节点的子孩子压入栈</span></span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">           Node pop = queue.remove();</span><br><span class="line">           System.out.print(pop.e + <span class="string">"-&gt;"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (pop.left != <span class="keyword">null</span>)</span><br><span class="line">               queue.add(pop.left);</span><br><span class="line">           <span class="keyword">if</span> (pop.right != <span class="keyword">null</span>)</span><br><span class="line">               queue.add(pop.right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>获取二分搜索树的最大最小值节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最小节点</span></span><br><span class="line"><span class="comment">//不断往左子树找，最后没有左子树的那个节点，就是最小节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">miniNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> miniNode(node.left);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大节点：同理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maxNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node.right == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       <span class="keyword">return</span> maxNode(node.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ol start="8">
<li>删除二分搜索树最小值，最大值的节点</li>
</ol>
<blockquote>
<ul>
<li>删除最小值节点：【不断往左子树寻找<ul>
<li>node.left = null ，找到最小节点   </li>
<li>该节点的右子树不一定为空，所以将右子树第一个节点返回作为新的根节点</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200505162228303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<blockquote>
<ul>
<li>同理：删除最大值节点：【不断往右子树寻找<ul>
<li>node.right = null , 即为最大值节点</li>
<li>该节点左子树不一定为空，所以将左子树第一个节点返回作为根节点</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// node.left==null 即：如果该节点为最小节点</span></span><br><span class="line">       <span class="comment">// 则返回该节点右子树的第一个节点</span></span><br><span class="line">       <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果左子树为空，则该节点右子树第一个为最大的节点</span></span><br><span class="line">           Node retNode = node.right;</span><br><span class="line">           <span class="comment">//断开与右子树的关系</span></span><br><span class="line">           node.right = <span class="keyword">null</span>;</span><br><span class="line">           size--;</span><br><span class="line">           <span class="comment">//返回新根节点</span></span><br><span class="line">           <span class="keyword">return</span> retNode;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//该节点不是最小节点，继续进入左子树。</span></span><br><span class="line">       <span class="comment">//用node.left 接收删除后的新根节点--&gt;A.left = C</span></span><br><span class="line">       node.left = removeMin(node.left);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回删除节点后新的二分搜索树的根</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// node.right==null    即：当前节点为最大节点</span></span><br><span class="line">       <span class="comment">// 返回左子树第一个节点</span></span><br><span class="line">       <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果右子树为空，则左子树第一个为最大的节点</span></span><br><span class="line">           Node retNode = node.left;</span><br><span class="line">           <span class="comment">//断开与左子树的关系</span></span><br><span class="line">           node.left = <span class="keyword">null</span>;</span><br><span class="line">           size--;</span><br><span class="line">           <span class="comment">//返回新根节点</span></span><br><span class="line">           <span class="keyword">return</span> retNode;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//当前节点不是最大节点,继续进入右子树寻找</span></span><br><span class="line">       node.right = removeMax(node.right);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>删除以node为根的二分搜索树中值为e的节点，并返回删除后的根节点。【递归算法</li>
</ol>
<blockquote>
<p>“待删除节点”有3种情况：</p>
<ul>
<li>左子树为空  =&gt;【删除最小节点</li>
<li>右子树为空  =&gt;【删除最大节点</li>
<li>左右子树都不为空【==如下图，删除d节点==<ul>
<li>1 .找到待删除节点 <strong>d</strong> 的右子树的最小节点 <strong>s</strong></li>
<li>2 .用 <strong>s</strong> 替代 <strong>d</strong> 的位置<ul>
<li><strong>s</strong> = miniNode(<strong>d</strong>.right);</li>
<li><strong>s</strong>.right = removeMini(<strong>d</strong>.right);</li>
<li><strong>s</strong>.left = <strong>d</strong>.left</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注：删除节点后依然维持着二分搜索树的性质</p>
<p><img src="https://img-blog.csdnimg.cn/20200505162146245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除值为e的节点，返回新的根节点 	</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//e&lt;当前节点，进入左子树</span></span><br><span class="line">           node.left = remove(node.left, e);</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//e&gt;当前节点，进入右子树</span></span><br><span class="line">           node.right = remove(node.right, e);</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//找到待删除节点e</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment">//待删除节点左子树为空</span></span><br><span class="line">           <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">               Node rightNode = node.right;</span><br><span class="line">               <span class="comment">//断开node和右子树的连接</span></span><br><span class="line">               node.right = <span class="keyword">null</span>;</span><br><span class="line">               size--;</span><br><span class="line">               <span class="comment">//返回删除节点后的（局部）根节点</span></span><br><span class="line">               <span class="keyword">return</span> rightNode;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//待删除节点右子树为空</span></span><br><span class="line">           <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">               Node leftNode = node.left;</span><br><span class="line">               <span class="comment">//断开node和右子树的连接</span></span><br><span class="line">               node.left = <span class="keyword">null</span>;</span><br><span class="line">               size--;</span><br><span class="line">               <span class="comment">//返回删除节点后的（局部）根节点</span></span><br><span class="line">               <span class="keyword">return</span> leftNode;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//待删除节点的左右子树均不为空</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//1.寻找“待删除节点”右子树的最小节点</span></span><br><span class="line">           Node rightMiniNode = miniNode(node.right);</span><br><span class="line">           <span class="comment">//2.删除待删节点的右子树的最小值并把新树的作为 “替代节点” 的右子树</span></span><br><span class="line">           rightMiniNode.right = removeMin(node.right);</span><br><span class="line">           <span class="comment">//3.把待删除节点的左子树接到 “替代节点”的左子树</span></span><br><span class="line">           rightMiniNode.left = node.left;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.将删除的节点断开联系</span></span><br><span class="line">           node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">return</span> rightMiniNode;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Java-JUC编程（1）</title>
    <url>/2020/05/21/Java-JUC%E7%BC%96%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h3><h4 id="1）区别"><a href="#1）区别" class="headerlink" title="1）区别"></a>1）区别</h4><ul>
<li>进程是程序的一次执行过程，操作系统分配资源给进程。</li>
<li>一个进程包含一个或多个线程，这些线程共享进程分配的资源</li>
<li>线程是任务调度和执行的基本单位 </li>
</ul>
<a id="more"></a>

<h4 id="2）并发与并行"><a href="#2）并发与并行" class="headerlink" title="2）并发与并行"></a>2）并发与并行</h4><ul>
<li>并发：5个人只有一把斧头，轮流砍一棵树</li>
<li>并行：5个人有五把斧头，一起砍一棵树</li>
</ul>
<h3 id="二、Synchronized和Lock的区别"><a href="#二、Synchronized和Lock的区别" class="headerlink" title="二、Synchronized和Lock的区别"></a>二、Synchronized和Lock的区别</h3><ol>
<li><p>synchronized是一个java关键字，Lock是juc包下的一个类</p>
</li>
<li><p>synchronized加锁解锁是一个自动的过程，Lock需要自己手动加锁解锁。</p>
</li>
<li><p>synchronized一个非公平锁，Lock可以手动指定。构造函数传参即可</p>
</li>
<li><p>synchronized适合锁少量的同步代码，Lock适合锁大量的同步代码</p>
</li>
<li><p>Synchronized 线程1获得锁–&gt;线程2等待，线程1阻塞–&gt;线程2一直等待）；Lock锁就不一定会等待下去；</p>
</li>
</ol>
<h3 id="三、消费者-生产者问题"><a href="#三、消费者-生产者问题" class="headerlink" title="三、消费者-生产者问题"></a>三、消费者-生产者问题</h3><h4 id="1）synchronized版–虚假唤醒"><a href="#1）synchronized版–虚假唤醒" class="headerlink" title="1）synchronized版–虚假唤醒"></a>1）synchronized版–虚假唤醒</h4><blockquote>
<p>出现的原因：存在多个消费者，生产者时。使用<code>if</code>判断等待条件</p>
<p>解决：把<code>if</code>改为<code>while</code>判断即可。当有多个生产者被唤醒时需要重新判断是否等待</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized版--生产者、消费者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  num=0</span></span><br><span class="line"><span class="comment"> *  生产者+1</span></span><br><span class="line"><span class="comment"> *  消费者-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  解决：使用while()判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区为1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// A1+1-&gt;OK   A2+1--&gt;wait()释放锁，A3+1--&gt;wait()释放锁  --&gt;此时A2,A3都挂data的等待队列上</span></span><br><span class="line">            <span class="comment">// C1-1-&gt;OK   --&gt;notifyAll()  --&gt;A2,A3都醒了。此时如果使用的是if判断，A2,A3会直接跳出if,去执行num++</span></span><br><span class="line">            <span class="comment">// 就造成了num=2的情况</span></span><br><span class="line">            <span class="comment">// 使用while()判断就会重新判断等待条件</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;"</span>+num);</span><br><span class="line">        <span class="comment">//唤醒</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;"</span>+num);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Data res = <span class="keyword">new</span> Data();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.put();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.put();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.pop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出现了很多&gt;1的情况</span></span><br><span class="line">A---&gt;<span class="number">1</span></span><br><span class="line">B---&gt;<span class="number">0</span></span><br><span class="line">C---&gt;<span class="number">1</span></span><br><span class="line">B---&gt;<span class="number">2</span></span><br><span class="line">...</span><br><span class="line">B---&gt;<span class="number">0</span></span><br><span class="line">C---&gt;<span class="number">1</span></span><br><span class="line">A---&gt;<span class="number">2</span></span><br><span class="line">C---&gt;<span class="number">3</span></span><br><span class="line">A---&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="3）Lock版"><a href="#3）Lock版" class="headerlink" title="3）Lock版"></a>3）Lock版</h4><blockquote>
<p>写法不同，使用的是while判断。不会出现虚假唤醒</p>
<p>但是执行的顺序不是有序的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lock锁版--生产者、消费者</span></span><br><span class="line"><span class="comment"> *    num=0</span></span><br><span class="line"><span class="comment"> *    生产者+1</span></span><br><span class="line"><span class="comment"> *    消费者-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// A+1-&gt;OK   A+1--&gt;wait()释放锁，B+1--&gt;wait()释放锁  --&gt;此时A,B都挂data的等待队列上</span></span><br><span class="line">                <span class="comment">// C-1-&gt;OK   --&gt;notifyAll()  --&gt;A,B都醒了。此时如果使用的是if判断，A,B会直接跳出if,去执行num++</span></span><br><span class="line">                <span class="comment">// 就造成了num=2的情况</span></span><br><span class="line">                <span class="comment">// 使用while()判断就会重新判断等待条件</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + num);</span><br><span class="line">            <span class="comment">//唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + num);</span><br><span class="line">            <span class="comment">//唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Data3 res = <span class="keyword">new</span> Data3();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.put();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.put();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.pop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    res.pop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A---&gt;<span class="number">1</span></span><br><span class="line">C---&gt;<span class="number">0</span></span><br><span class="line">A---&gt;<span class="number">1</span></span><br><span class="line">D---&gt;<span class="number">0</span></span><br><span class="line">...</span><br><span class="line">C---&gt;<span class="number">0</span></span><br><span class="line">B---&gt;<span class="number">1</span></span><br><span class="line">C---&gt;<span class="number">0</span></span><br><span class="line">B---&gt;<span class="number">1</span></span><br><span class="line">C---&gt;<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="4）Condition实现精准通知唤醒"><a href="#4）Condition实现精准通知唤醒" class="headerlink" title="4）Condition实现精准通知唤醒"></a>4）Condition实现精准通知唤醒</h4><blockquote>
<p>可以实现线程有序的执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.xu.multithread.kuangshen.juc.pc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 利用Lock、Condition实现精准通知</span></span><br><span class="line"><span class="comment"> * 线程交替</span></span><br><span class="line"><span class="comment"> *  标志位：num</span></span><br><span class="line"><span class="comment"> *  num=1--&gt;A执行 --&gt;通知B</span></span><br><span class="line"><span class="comment"> *  num=2--&gt;B执行 --&gt;通知C</span></span><br><span class="line"><span class="comment"> *  num=3--&gt;C执行 --&gt;通知A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-19 12:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// num!=1 --&gt;进入condition1的等待队列</span></span><br><span class="line">            <span class="keyword">while</span> (num!=<span class="number">1</span>)&#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;AAA"</span>);</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 调整num,并唤醒condition2等待队列中的一个线程</span></span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num!=<span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;BBB"</span>);</span><br><span class="line">            num = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num!=<span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"---&gt;CCC\n"</span>);</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC4</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Data4 res = <span class="keyword">new</span> Data4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">               res.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">               res.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">               res.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、8锁现象理解synchronized锁"><a href="#四、8锁现象理解synchronized锁" class="headerlink" title="四、8锁现象理解synchronized锁"></a>四、8锁现象理解synchronized锁</h3><p>先总结一下</p>
<ol>
<li>synchronized 锁的对象是方法的调用者！谁先获得锁，谁先执行</li>
<li>当一个线程访问一个A类的同步方法，其他线程可以访问A类的普通方法</li>
<li>静态同步方法锁的是Class对象，所有该类对象共享这一把锁</li>
<li>静态同步方法锁的是Class,普通同步方法锁的是调用该方法的对象。使用的是不同锁，不影响</li>
</ol>
<p>再看代码：</p>
<p>第二种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、 增加了一个普通方法后！先执行发短信还是Hello？ 普通方法</span></span><br><span class="line"><span class="comment"> * 4、 两个对象，两个同步方法， 发短信还是 打电话？ // 打电话</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：当一个线程访问一个A类的同步方法，其他线程可以访问A类的普通方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个对象，两个调用者，两把锁！</span></span><br><span class="line">        Phone2 phone1 = <span class="keyword">new</span> Phone2();</span><br><span class="line">        Phone2 phone2 = <span class="keyword">new</span> Phone2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁的存在</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// hello()未使用synchronized修饰，</span></span><br><span class="line">            <span class="comment">// 当一个线程访问一个A类的同步方法，其他线程可以访问A类的普通方法</span></span><br><span class="line">            <span class="comment">//phone1.hello();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用的是不同的锁，互不影响</span></span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized 锁的对象是方法的调用者！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里没有锁！不是同步方法，不受锁的影响</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、1个静态的同步方法，1个普通的同步方法 ，一个对象，先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> * 2、1个静态的同步方法，1个普通的同步方法 ，两个对象，先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：静态同步方法锁的是Class,普通同步方法锁的是调用该方法的对象。使用的是不同锁，不影响</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个对象的Class类模板只有一个，static，锁的是Class</span></span><br><span class="line">        Phone4 phone1 = <span class="keyword">new</span> Phone4();</span><br><span class="line">        Phone4 phone2 = <span class="keyword">new</span> Phone4();</span><br><span class="line">        <span class="comment">//锁的存在</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// sendSms()：静态同步方法 Class锁</span></span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 普通同步方法，使用的是phone1锁。所以先打电话--&gt;发短信</span></span><br><span class="line">            <span class="comment">// sendSms()：静态同步方法 Class锁 该方法休眠4s不影响call()的执行，因为使用的不是同一把锁</span></span><br><span class="line">            <span class="comment">// phone1.call();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不是一把锁，不影响</span></span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Phone3唯一的一个 Class 对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone4</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的同步方法 锁的是 Class 类模板</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通的同步方法  锁的调用者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、线程安全的集合、映射"><a href="#五、线程安全的集合、映射" class="headerlink" title="五、线程安全的集合、映射"></a>五、线程安全的集合、映射</h3><p>先总结：</p>
<ol>
<li>可以使用集合的工具类Collections中的方法使之安全。比如</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collectoins.synchronizedList(list)</span><br><span class="line">Collections.synchronizedSet(set);</span><br><span class="line">Collections.synchronizedMap(map);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>Juc</code>包下的安全类。比如</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CopyOnWriteArrayList</span><br><span class="line">ConcurrentHashSet</span><br><span class="line">ConcurrentHashMap</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>为啥不推荐使用Vector【jdk1.0<ol>
<li>Vector使用的是synchronized的同步方法，效率更低</li>
<li>CopyOnWriteArrayList使用的是lock锁。【锁的粒度小，可控</li>
</ol>
</li>
</ol>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//报：java.util.ConcurrentModificationException</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//List list = new Vector(); // jdk1.0</span></span><br><span class="line">        <span class="comment">//List&lt;String&gt; list = new ArrayList&lt;&gt;();  //jdk1.2</span></span><br><span class="line">        <span class="comment">//List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line"></span><br><span class="line">        List list2 = <span class="keyword">new</span> Vector();</span><br><span class="line">        list2.add(<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                list.add(String.valueOf(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//不安全的set</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何安全-----&gt;Collections工具类和Juc包下</span></span><br><span class="line">        Set&lt;String&gt; safeSet = Collections.synchronizedSet(set);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JUC  ConcurrentHashSet</span></span><br><span class="line">        Set&lt;String&gt; safeSet2 = <span class="keyword">new</span> ConcurrentHashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不安全的map</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//安全的map</span></span><br><span class="line">        Map&lt;String, String&gt; safeMap = Collections.synchronizedMap(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JUC ConcurrentHashMap</span></span><br><span class="line">        Map&lt;String,String&gt; safeMap2 = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、Callable执行流程"><a href="#六、Callable执行流程" class="headerlink" title="六、Callable执行流程"></a>六、Callable执行流程</h3><p>先看下几个类之间的关系吧</p>
<blockquote>
<ol>
<li>Runnable和Callable接口都是一个函数式接口</li>
<li>FutrueTask 间接实现了Runnable接口。所以Thread构造函数可以接受FutureTask来开启线程</li>
<li>从图中可以看出FutrueTask 可以接受一个Callable</li>
</ol>
<p>注：Callable接口的泛型是线程体的<strong>返回类型</strong></p>
</blockquote>
<p><img src="img%5CRunnable.png" alt="Runnable"></p>
<p>如何使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call()执行了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1998</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(thread);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(task,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回值在task里面----该方法可能产生阻塞（一直等待结果</span></span><br><span class="line">        Integer ret = task.get();</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、常用辅助类"><a href="#七、常用辅助类" class="headerlink" title="七、常用辅助类"></a>七、常用辅助类</h3><h4 id="1）CountDownLatch"><a href="#1）CountDownLatch" class="headerlink" title="1）CountDownLatch"></a>1）CountDownLatch</h4><blockquote>
<p>减法计数器</p>
<p>举例：5个人吃完饭，才收拾桌子</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.xu.multithread.kuangshen.juc.add;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 减法计数器</span></span><br><span class="line"><span class="comment"> * 举例：5个人吃完饭，才收拾桌子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-21 14:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总数5</span></span><br><span class="line">        CountDownLatch downLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"吃完了..."</span>);</span><br><span class="line">                <span class="comment">// 计数器-1</span></span><br><span class="line">                downLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待5个线程结束</span></span><br><span class="line">        downLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"收拾桌子..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）CyclicBarrier"><a href="#2）CyclicBarrier" class="headerlink" title="2）CyclicBarrier"></a>2）CyclicBarrier</h4><blockquote>
<p>加法计数器</p>
<p>举例：集齐7颗龙珠，才能召唤神龙</p>
<p>说明：使用7条线程集齐龙珠，只有7条线程都执行后，才能执行“召唤神龙”线程（CyclicBarrier</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCyclicBarrier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数--传入计数的值，和一个线程体Runnable接口</span></span><br><span class="line">        <span class="comment">// 如果是8的话进入一直等待状态</span></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"召唤神龙成功！！"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"集齐了第"</span>+temp+<span class="string">"号龙珠"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用barrier进入阻塞,直到最后才执行CyclicBarrier</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>集齐了第<span class="number">1</span>号龙珠</span><br><span class="line">Thread-<span class="number">4</span>集齐了第<span class="number">5</span>号龙珠</span><br><span class="line">Thread-<span class="number">3</span>集齐了第<span class="number">4</span>号龙珠</span><br><span class="line">Thread-<span class="number">1</span>集齐了第<span class="number">2</span>号龙珠</span><br><span class="line">Thread-<span class="number">2</span>集齐了第<span class="number">3</span>号龙珠</span><br><span class="line">Thread-<span class="number">5</span>集齐了第<span class="number">6</span>号龙珠</span><br><span class="line">Thread-<span class="number">6</span>集齐了第<span class="number">7</span>号龙珠</span><br><span class="line">召唤神龙成功！！</span><br></pre></td></tr></table></figure>

<h4 id="3）Semaphore：信号量"><a href="#3）Semaphore：信号量" class="headerlink" title="3）Semaphore：信号量"></a>3）Semaphore：信号量</h4><blockquote>
<p>信号量</p>
<p>解决问题：多个共享资源的互斥</p>
<p>举例：抢车位，6辆车，只有3个车位</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数：共享的资源数    【停留的线程数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">// 获取资源，没有则等待</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"抢到了车位"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;离开了车位"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放资源，通知唤醒</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>抢到了车位</span><br><span class="line">Thread-<span class="number">2</span>抢到了车位</span><br><span class="line">Thread-<span class="number">1</span>抢到了车位</span><br><span class="line">Thread-<span class="number">1</span>--&gt;离开了车位</span><br><span class="line">Thread-<span class="number">0</span>--&gt;离开了车位</span><br><span class="line">Thread-<span class="number">2</span>--&gt;离开了车位</span><br><span class="line">Thread-<span class="number">4</span>抢到了车位</span><br><span class="line">Thread-<span class="number">3</span>抢到了车位</span><br><span class="line">Thread-<span class="number">5</span>抢到了车位</span><br><span class="line">Thread-<span class="number">4</span>--&gt;离开了车位</span><br><span class="line">Thread-<span class="number">3</span>--&gt;离开了车位</span><br><span class="line">Thread-<span class="number">5</span>--&gt;离开了车位</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-多线程基础</title>
    <url>/2020/05/21/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="一、线程的创建方式"><a href="#一、线程的创建方式" class="headerlink" title="一、线程的创建方式"></a>一、线程的创建方式</h3><p>1）继承<code>Thread</code>类</p>
<p>2）实现<code>Runnable</code>接口</p>
<p>3）实现<code>Callable</code>接口</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread-1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread-2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现Callable接口方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread-3"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCreate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1()).start();</span><br><span class="line">        <span class="keyword">new</span> MyThread2().start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实现Callable接口</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread3());</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程的返回值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer i = task.get();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、线程的状态"><a href="#二、线程的状态" class="headerlink" title="二、线程的状态"></a>二、线程的状态</h3><h4 id="1）状态转换图"><a href="#1）状态转换图" class="headerlink" title="1）状态转换图"></a>1）状态转换图</h4><p>线程有5个状态：新建、就绪、运行、阻塞、终止<br><img src="https://img-blog.csdnimg.cn/20200517161814690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2）常见方法"><a href="#2）常见方法" class="headerlink" title="2）常见方法"></a>2）常见方法</h4><table>
<thead>
<tr>
<th></th>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>静态方法</strong></td>
<td>Thread.sleep(int time)</td>
<td>使当前线程进入休眠，不会放对象锁</td>
</tr>
<tr>
<td><strong>静态方法</strong></td>
<td>Thread.yield()</td>
<td>使当前线程让出CPU—&gt;进入就绪态</td>
</tr>
<tr>
<td>实例方法</td>
<td>t1.join()</td>
<td>类似插队，其他线程需要等待t1结束后，才能继续</td>
</tr>
<tr>
<td>实例方法</td>
<td>t1.get/setPriority(int n)</td>
<td>用于获取当前和设置线程的优先级</td>
</tr>
<tr>
<td>实例方法</td>
<td>t1.getState()</td>
<td>获取线程状态</td>
</tr>
<tr>
<td>实例方法</td>
<td>t1.setDaemon(true)</td>
<td>设置当前为守护线程</td>
</tr>
</tbody></table>
<h3 id="三、线程同步"><a href="#三、线程同步" class="headerlink" title="三、线程同步"></a>三、线程同步</h3><h4 id="1）同步方法"><a href="#1）同步方法" class="headerlink" title="1）同步方法"></a>1）同步方法</h4><ol>
<li>使用<code>synchronized</code>关键字，它包括两种用法：synchronized 方法和synchronized块.</li>
</ol>
<p>同步方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> method（）&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>同步方法锁的是对象本身<code>this</code></p>
</li>
<li><p>缺陷：若将一个大的方法申明为<code>synchronized</code>将会影响效率</p>
</li>
</ol>
<h4 id="2）同步代码块"><a href="#2）同步代码块" class="headerlink" title="2）同步代码块"></a>2）同步代码块</h4><ol>
<li><p>同步块：<code>synchronized（obj）{}</code></p>
</li>
<li><p><strong><code>obj</code> 称之为同步监视器</strong></p>
<ul>
<li>obj可以是任何对象，但是推荐使用共享资源作为同步监视器</li>
<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class</li>
</ul>
</li>
<li><p>同步监视器的执行过程</p>
<ul>
<li>第一个线程访问，锁定同步监视器，执行其中代码.</li>
<li>第二个线程访问，发现同步监视器被锁定，无法访问.</li>
<li>第一个线程访问完毕，解锁同步监视器.</li>
<li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问</li>
</ul>
</li>
</ol>
<p>示例：银行取钱</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2夫妻同时到银行取钱</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 同步块：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-16 21:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//账户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> money; <span class="comment">//余额</span></span><br><span class="line">    String name; <span class="comment">//卡名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//银行：模拟取款</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Darwing</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Account account;</span><br><span class="line">    <span class="comment">//取了多少钱</span></span><br><span class="line">    <span class="keyword">int</span> drawMoney;</span><br><span class="line">    <span class="comment">//手里多少钱</span></span><br><span class="line">    <span class="keyword">int</span> nowMoney;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Darwing</span><span class="params">(String name, Account account, <span class="keyword">int</span> drawMoney)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawMoney = drawMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized方法：默认锁的是this。这里如果锁run()方法的话，锁的对象就是Drawing对象，相当于锁住银行了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       takeMoney();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 锁的对象是变化的量，需要增删改的量</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account)&#123;</span><br><span class="line">            <span class="comment">//余额不足</span></span><br><span class="line">            <span class="keyword">if</span>(account.money&lt;drawMoney)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName()+<span class="string">"余额不足..."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//将2个线程都堵在这里，放大问题</span></span><br><span class="line">                <span class="comment">// you,girlFriend线程都发现有100,但是钱被girl取了，变为0</span></span><br><span class="line">                <span class="comment">// 当you醒过来以为还有100，就也取了50</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取钱</span></span><br><span class="line">            account.money -= drawMoney;</span><br><span class="line">            nowMoney += drawMoney;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">"取了："</span>+drawMoney);</span><br><span class="line">            System.out.println(account.name+<span class="string">"余额有："</span>+account.money);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">"手里有："</span>+nowMoney+<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="number">100</span>, <span class="string">"结婚基金"</span>);</span><br><span class="line"></span><br><span class="line">        Darwing you = <span class="keyword">new</span> Darwing(<span class="string">"you"</span>,account,<span class="number">50</span>);</span><br><span class="line">        Darwing girl = <span class="keyword">new</span> Darwing(<span class="string">"girl"</span>,account,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        you.start();</span><br><span class="line">        girl.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）死锁"><a href="#3）死锁" class="headerlink" title="3）死锁"></a>3）死锁</h4><p>形成条件：线程互相持有对方需要的资源—&gt;循环等待</p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200517161938174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzAxMjk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>如何解决</strong>：破坏其中一个或多个条件即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试死锁</span></span><br><span class="line"><span class="comment"> *      多个线程互相拥有对方需要的资源，形成僵持</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-16 22:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lock1;</span><br><span class="line">    <span class="keyword">private</span> String lock2;</span><br><span class="line"></span><br><span class="line">    Player(String lock1, String lock2, String name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.lock1 = lock1;</span><br><span class="line">        <span class="keyword">this</span>.lock2 = lock2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//确保2线程都启动</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            noDeadLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死锁：持有锁，并想获得对方的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" have "</span> + lock1);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" need "</span> + lock2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//保证2线程都启动</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" get "</span> + lock2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决死锁：持有锁，等待对方放弃锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">noDeadLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" have "</span> + lock1);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" need "</span> + lock2);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放弃lock1,请求lock2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" get "</span> + lock2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String lock1 = <span class="keyword">new</span> String(<span class="string">"lock-V"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String lock2 = <span class="keyword">new</span> String(<span class="string">"lock-H"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Player a = <span class="keyword">new</span> Player(lock1, lock2, <span class="string">"A"</span>);</span><br><span class="line">        Player b = <span class="keyword">new</span> Player(lock2, lock1, <span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4）Lock锁"><a href="#4）Lock锁" class="headerlink" title="4）Lock锁"></a>4）Lock锁</h4><ul>
<li>JDK1.5 开始提供的显示锁。使用Lock对象</li>
<li><code>java.util.concurrent.locks.Lock</code>接口是控制多个线程对共享资源进行访问的工具。<br>锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，<strong>线程开始访问共享资源之前应先获得Lock对象</strong></li>
<li><code>ReentrantLock</code>（可重入锁）类实现了Lock，它拥有与<code>synchronized</code> 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是<code>ReentrantLock</code>，可以显式加锁、释放锁。</li>
</ul>
<p>示例：买票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Lock锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-21 9:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tickets2</span></span>&#123;</span><br><span class="line">    <span class="comment">// 票的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 买票的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"卖出了第"</span>+num--+<span class="string">"张票"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Tickets2 res = <span class="keyword">new</span> Tickets2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保线程启动</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                res.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                res.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                res.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A卖出了第<span class="number">20</span>张票</span><br><span class="line">A卖出了第<span class="number">19</span>张票</span><br><span class="line">A卖出了第<span class="number">18</span>张票</span><br><span class="line">A卖出了第<span class="number">17</span>张票</span><br><span class="line">A卖出了第<span class="number">16</span>张票</span><br><span class="line">A卖出了第<span class="number">15</span>张票</span><br><span class="line">A卖出了第<span class="number">14</span>张票</span><br><span class="line">A卖出了第<span class="number">13</span>张票</span><br><span class="line">B卖出了第<span class="number">12</span>张票</span><br><span class="line">B卖出了第<span class="number">11</span>张票</span><br><span class="line">B卖出了第<span class="number">10</span>张票</span><br><span class="line">B卖出了第<span class="number">9</span>张票</span><br><span class="line">B卖出了第<span class="number">8</span>张票</span><br><span class="line">B卖出了第<span class="number">7</span>张票</span><br><span class="line">B卖出了第<span class="number">6</span>张票</span><br><span class="line">B卖出了第<span class="number">5</span>张票</span><br><span class="line">C卖出了第<span class="number">4</span>张票</span><br><span class="line">C卖出了第<span class="number">3</span>张票</span><br><span class="line">C卖出了第<span class="number">2</span>张票</span><br><span class="line">C卖出了第<span class="number">1</span>张票</span><br></pre></td></tr></table></figure>

<h3 id="四、线程通信"><a href="#四、线程通信" class="headerlink" title="四、线程通信"></a>四、线程通信</h3><p>多个线程互相协作，共同完成任务。</p>
<p>涉及的方法</p>
<table>
<thead>
<tr>
<th>wait()</th>
<th>使当前线程进入阻塞,并释放锁</th>
</tr>
</thead>
<tbody><tr>
<td>wait(int time)</td>
<td>等待指定的毫秒数</td>
</tr>
<tr>
<td>notify()</td>
<td>唤醒一个等待该（对象锁）线程并使该线程开始执行</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>notifyAll 会唤醒所有等待该(对象锁)线程，</td>
</tr>
</tbody></table>
<p>注意： </p>
<ul>
<li><code>wait()、notify()、notifyAll()</code>是继承自Object的本地final方法</li>
<li>上面的方法需要配合<code>synchronized</code>关键字使用，即放在同步方法或代码块中使用。【<strong>说明当前线程已经获得锁</strong></li>
</ul>
<h4 id="1）生产者-消费者问题"><a href="#1）生产者-消费者问题" class="headerlink" title="1）生产者-消费者问题"></a>1）生产者-消费者问题</h4><ul>
<li>生产者—&gt;缓冲区   缓冲区满–&gt;等待消费</li>
<li>消费者&lt;—缓冲区   缓冲区空–&gt;等待生产</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.xu.multithread.kuangshen.pc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者--消费者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      生产者---&gt;缓冲区   缓冲区满--&gt;通知消费者消费</span></span><br><span class="line"><span class="comment"> *      消费者&lt;---缓冲区   缓冲区空--&gt;通知生产者生产</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实例：生产者，消费者，产品，缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> a_apple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-17 10:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="comment">//产品编号</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductBuffer</span></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区大小 5</span></span><br><span class="line">    List&lt;Product&gt; buffer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxCapacity = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将产品放入缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Product product)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 实际操作的是buffer，所以这里使用buffer锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (buffer)&#123;</span><br><span class="line">            <span class="comment">// 缓冲区满--&gt;放弃锁--&gt;阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (maxCapacity == buffer.size())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"缓冲区已满..."</span>);</span><br><span class="line">                    buffer.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//放入</span></span><br><span class="line">            buffer.add(product);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"生产了："</span>+product.i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知消费</span></span><br><span class="line">            buffer.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓冲区获取商品   synchronized锁的this==缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (buffer)&#123;</span><br><span class="line">            <span class="comment">// 缓冲区空--&gt;等待</span></span><br><span class="line">            <span class="keyword">while</span>(buffer.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//进入阻塞--&gt;放弃buffer锁</span></span><br><span class="line">                    System.out.println(<span class="string">"----&gt;缓冲区空了&lt;----"</span>);</span><br><span class="line">                    buffer.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//随机取出一个</span></span><br><span class="line">            Product product = buffer.remove(<span class="keyword">new</span> Random().nextInt(buffer.size()));</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;消费了："</span>+product.i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知生产</span></span><br><span class="line">            buffer.notifyAll();</span><br><span class="line">            <span class="comment">//返回产品</span></span><br><span class="line">            <span class="keyword">return</span> product;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ProductBuffer buffer = <span class="keyword">new</span> ProductBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者-1   </span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//放入10个产品</span></span><br><span class="line">                buffer.push(<span class="keyword">new</span> Product(i));</span><br><span class="line">                <span class="comment">//sleep(1000): 每生产一个就停一下</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者-2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">11</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//放入10个产品</span></span><br><span class="line">                buffer.push(<span class="keyword">new</span> Product(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者-1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                buffer.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者-2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">11</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                buffer.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A生产了：<span class="number">1</span></span><br><span class="line">A生产了：<span class="number">2</span></span><br><span class="line">A生产了：<span class="number">3</span></span><br><span class="line">A生产了：<span class="number">4</span></span><br><span class="line">A生产了：<span class="number">5</span></span><br><span class="line">缓冲区已满...</span><br><span class="line">B--&gt;消费了：<span class="number">1</span></span><br><span class="line">B--&gt;消费了：<span class="number">2</span></span><br><span class="line">B--&gt;消费了：<span class="number">5</span></span><br><span class="line">B--&gt;消费了：<span class="number">3</span></span><br><span class="line">B--&gt;消费了：<span class="number">4</span></span><br><span class="line">----&gt;缓冲区空了&lt;----</span><br><span class="line">C生产了：<span class="number">11</span></span><br><span class="line">C生产了：<span class="number">12</span></span><br><span class="line">C生产了：<span class="number">13</span></span><br><span class="line">C生产了：<span class="number">14</span></span><br><span class="line">C生产了：<span class="number">15</span></span><br><span class="line">缓冲区已满...</span><br><span class="line">B--&gt;消费了：<span class="number">12</span></span><br><span class="line">B--&gt;消费了：<span class="number">15</span></span><br><span class="line">B--&gt;消费了：<span class="number">13</span></span><br><span class="line">B--&gt;消费了：<span class="number">14</span></span><br><span class="line">B--&gt;消费了：<span class="number">11</span></span><br><span class="line">A生产了：<span class="number">6</span></span><br><span class="line">A生产了：<span class="number">7</span></span><br><span class="line">A生产了：<span class="number">8</span></span><br><span class="line">A生产了：<span class="number">9</span></span><br><span class="line">A生产了：<span class="number">10</span></span><br><span class="line">D--&gt;消费了：<span class="number">9</span></span><br><span class="line">D--&gt;消费了：<span class="number">10</span></span><br><span class="line">D--&gt;消费了：<span class="number">6</span></span><br><span class="line">D--&gt;消费了：<span class="number">7</span></span><br><span class="line">D--&gt;消费了：<span class="number">8</span></span><br><span class="line">----&gt;缓冲区空了&lt;----</span><br><span class="line">C生产了：<span class="number">16</span></span><br><span class="line">C生产了：<span class="number">17</span></span><br><span class="line">C生产了：<span class="number">18</span></span><br><span class="line">C生产了：<span class="number">19</span></span><br><span class="line">C生产了：<span class="number">20</span></span><br><span class="line">D--&gt;消费了：<span class="number">20</span></span><br><span class="line">D--&gt;消费了：<span class="number">19</span></span><br><span class="line">D--&gt;消费了：<span class="number">16</span></span><br><span class="line">D--&gt;消费了：<span class="number">18</span></span><br><span class="line">D--&gt;消费了：<span class="number">17</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8-Stream流</title>
    <url>/2020/05/22/Java8--Stream%E6%B5%81/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>java.util.Stream</code> 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如<code>java.util.Collection</code> 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。</p>
<a id="more"></a>

<h3 id="一、流的创建方式"><a href="#一、流的创建方式" class="headerlink" title="一、流的创建方式"></a>一、流的创建方式</h3><blockquote>
<ol>
<li>从Collection(集合)中构建；</li>
<li>从值<code>value</code>(<code>Stream.of()</code>)中构建；</li>
<li>从数组中构建(<code>Arrays.stream()</code>)；</li>
<li>从文件中构建；</li>
<li>由函数生成: 创建无限流；</li>
</ol>
</blockquote>
<p>1）从集合中获取流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从集合中获取流</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"bb"</span>);</span><br><span class="line">        list.add(<span class="string">"ccc"</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">        <span class="comment">//流只能使用一次，第二次需要重新获取</span></span><br><span class="line">        <span class="comment">//报：stream has already been operated upon or closed</span></span><br><span class="line">        <span class="comment">//stream.forEach(x -&gt; System.out.println(x));</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2）使用<code>Stream.of()</code>获取流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从值`value`(`Stream.of()`)中构建；</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">      stream.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>3）使用<code>Arrays.stream()</code>从数组中获取流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从数组中构建(`Arrays.stream()`)；</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromArrays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     String[] arr = &#123;<span class="string">"aa"</span>, <span class="string">"ee"</span>, <span class="string">"ii"</span>&#125;;</span><br><span class="line">     Stream&lt;String&gt; stream = Arrays.stream(arr);</span><br><span class="line">     stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>4）从文件中获取流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从文件中创建流</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     Path path = Paths.get(<span class="string">"D:\\IdeaProjects\\DataStructure\\Data\\src\\pers\\xu\\lambda\\LambdaDemo.java"</span>);</span><br><span class="line">     Stream&lt;String&gt; stream = Files.lines(path);</span><br><span class="line">     stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>5）使用函数创建无效流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数创建的无限流-1</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromIterate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">2</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">5</span>);</span><br><span class="line">       stream.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 函数创建的无限流-2</span></span><br><span class="line">   <span class="comment">// Stream.generate(生产者接口)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromGenerate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Stream&lt;Double&gt; stream = Stream.generate(Math::random).limit(<span class="number">5</span>);</span><br><span class="line">       stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//类名::静态方法    实例参数列表要与抽象方法的参数列表一致</span></span><br><span class="line">       <span class="comment">//Stream&lt;Double&gt; stream2 = Stream.generate(()-&gt;Math.random()).limit(5);</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>6）示例：创建一个提供Custom对象的无限流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Custom</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Custom</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Custom</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Custom</span><span class="params">(<span class="keyword">int</span> id, String name)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Custom&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Custom o1, Custom o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.id-o2.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类实现 供给型接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CusSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Custom</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Custom <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       index=random.nextInt(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Custom(index,<span class="string">"name-"</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建流</span></span><br><span class="line">        <span class="comment">//generate()：参数接收一个供给型接口</span></span><br><span class="line">        Stream&lt;Custom&gt; stream = Stream.generate(<span class="keyword">new</span> CusSupplier()).</span><br><span class="line">                limit(<span class="number">5</span>).</span><br><span class="line">                sorted(Comparator.comparing(Custom::getId)); <span class="comment">//根据id进行排序</span></span><br><span class="line">        <span class="comment">//sorted(new Custom());</span></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line">        <span class="comment">//创建流</span></span><br><span class="line">        <span class="comment">//generate()：参数接收一个供给型接口.</span></span><br><span class="line">        <span class="comment">//作用：无限生成流元素</span></span><br><span class="line">        List&lt;Custom&gt; list = Stream.generate(<span class="keyword">new</span> CusSupplier()).</span><br><span class="line">                limit(<span class="number">3</span>).</span><br><span class="line">                sorted(<span class="keyword">new</span> Custom()) <span class="comment">//Custom实现了Comparator接口</span></span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Custom custom : list) &#123;</span><br><span class="line">            System.out.println(custom);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、流的中间操作"><a href="#二、流的中间操作" class="headerlink" title="二、流的中间操作"></a>二、流的中间操作</h3><blockquote>
<p> filter、limit、skip、map、flatMap的使用</p>
<ul>
<li>filter：过滤</li>
<li>limit：返回一个不超过给定长度的流；</li>
<li>skip：返回一个扔掉了前n 个元素的流；【skip(k)：跳过前k个元素</li>
<li>map：将流中元素其映射成一个新的元素</li>
<li>flatMap：把一个流中的每个值都换成另一个流，然后把所有的流连接</li>
</ul>
</blockquote>
<p>1）filter()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * filter : 接收一个断言式接口（Predicate）作为参数，</span></span><br><span class="line"><span class="comment">    * 			并返回一个包括所有符合条件的元素的流；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Integer&gt; nums = Arrays.asList(<span class="number">10</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">       <span class="comment">//从流中选出偶数，且没有重复</span></span><br><span class="line">       nums.stream().filter(i -&gt; i%<span class="number">2</span>==<span class="number">0</span>)  <span class="comment">//过滤</span></span><br><span class="line">               .distinct()  <span class="comment">//去重</span></span><br><span class="line">               .sorted((x,y) -&gt; y.compareTo(x)) <span class="comment">//排序</span></span><br><span class="line">               .forEach(x -&gt; System.out.println(x+<span class="string">"-"</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>2）limit()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * limit ():</span></span><br><span class="line"><span class="comment">   *      流支持`limit(n)`方法，该方法会返回一个不超过给定长度的流；</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">      String[] arr = &#123;<span class="string">"aa"</span>,<span class="string">"b"</span>,<span class="string">"cc"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">     Arrays.stream(arr).</span><br><span class="line">             limit(<span class="number">3</span>). <span class="comment">//取前3个</span></span><br><span class="line">             forEach(System.out::println);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>3）skip()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * skip():</span></span><br><span class="line"><span class="comment">    *      返回一个扔掉了前n 个元素的流；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSkip</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String[] arr = &#123;<span class="string">"aa"</span>,<span class="string">"b"</span>,<span class="string">"cc"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">       Arrays.stream(arr).</span><br><span class="line">               skip(<span class="number">2</span>). <span class="comment">//跳过前2个 [aa,b</span></span><br><span class="line">               forEach(System.out::println);</span><br><span class="line">       <span class="comment">//结果：cc d</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>4）map()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * map()：</span></span><br><span class="line"><span class="comment">    *      这个函数会被应用到每个元素上，</span></span><br><span class="line"><span class="comment">    *      把流中的元素‘转换’为另一个元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">       nums.stream().map(i -&gt; i*<span class="number">2</span> ) <span class="comment">//将流中元素都转换为2倍</span></span><br><span class="line">               .collect(Collectors.toList())</span><br><span class="line">               .forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * map()示例：</span></span><br><span class="line"><span class="comment">    * 将字符串元素转换为它的长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;String&gt; strs = Arrays.asList(<span class="string">"a"</span>, <span class="string">"bb"</span>, <span class="string">"ccc"</span>, <span class="string">"dd"</span>);</span><br><span class="line">       strs.stream().map(x -&gt; x.length())</span><br><span class="line">               .collect(Collectors.toList())</span><br><span class="line">               .forEach(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>5）flatmap()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * flatmap()：</span></span><br><span class="line"><span class="comment">    *      把一个流中的每个值都换成另一个流，</span></span><br><span class="line"><span class="comment">    *      然后把所有的流连接起来成为一个流</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//将 words去重输出字符</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String[] arr = &#123;<span class="string">"Hello"</span>,<span class="string">"Tom"</span>,<span class="string">"House"</span>&#125;;</span><br><span class="line">       <span class="comment">//把一个字符串变成了一个字符串数组</span></span><br><span class="line">       Stream&lt;String[]&gt; stream = Arrays.stream(arr).</span><br><span class="line">               map(x -&gt; x.split(<span class="string">""</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">//stream.forEach(arr2 -&gt; System.out.println("str-length:"+arr2.length));</span></span><br><span class="line"></span><br><span class="line">       Stream&lt;String&gt; stringStream = stream.flatMap(s -&gt; Arrays.stream(s));</span><br><span class="line"></span><br><span class="line">       stringStream.</span><br><span class="line">               distinct().</span><br><span class="line">               forEach(x -&gt; System.out.print(x+<span class="string">"-"</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、流的终止操作"><a href="#三、流的终止操作" class="headerlink" title="三、流的终止操作"></a>三、流的终止操作</h3><blockquote>
<p> <strong>终端操作</strong>会<strong>从 流的流水线 生成结果</strong>。<br>不做终止操作，中间环节就不执行，体现的就是延迟加载的思想；<br>只有用的时候，中间环节再进行。<br>其<strong>结果</strong>可以是<strong>任何不是流的值</strong><br>例如：List、Integer，甚至是 void </p>
</blockquote>
<blockquote>
<ul>
<li>match：查看元素是否匹配(返回<strong>boolean</strong>)，<ul>
<li><code>allMatch()</code>: 检查<strong>是否匹配所有元素</strong> </li>
<li><code>anyMatch()</code> : 检查<strong>是否至少匹配一个元素</strong> </li>
<li><code>noneMatch()</code>: 检查<strong>是否与 所有元素 都不匹配</strong> </li>
</ul>
</li>
<li>find：<ul>
<li><code>isPresent()</code>将在Optional包含值的时候返回true, 否则返回false；</li>
<li>ifPresent(Consumer<T> block)`会在值存在的时候执行给定的代码块；</li>
<li><code>T get()</code>会在值存在时返回值，否则抛出一个NoSuchElement异常；</li>
<li><code>T orElse(T other)</code>会在值存在时返回值，否则返回一个默认值；</li>
<li><code>Optional&lt;T&gt; of(T value)</code>  : 通过value构造一个Optional；</li>
</ul>
</li>
<li>max(Comparator c)：  返回<strong>流中最大值</strong> </li>
<li>min(Comparator c)：返回<strong>流中最小值</strong> </li>
<li>forEach(Consumer c)：<strong>内部迭代</strong> </li>
<li>reduce()：<ul>
<li>把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。</li>
<li>从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。</li>
<li>例如 Stream 的 sum 就相当于<code>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);</code></li>
<li>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</li>
</ul>
</li>
</ul>
</blockquote>
<p>1）count()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * count():</span></span><br><span class="line"><span class="comment">    *      对流中的元素进行计数，返回一个long类型值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">           list.add(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//list中奇数的个数</span></span><br><span class="line">       <span class="keyword">long</span> count = list.stream().</span><br><span class="line">               filter(x -&gt; x % <span class="number">2</span> == <span class="number">1</span>).count();</span><br><span class="line"></span><br><span class="line">       System.out.println(count);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>2）match()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matchTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    out.println(arr.stream().allMatch(i -&gt; i &gt; <span class="number">10</span>));</span><br><span class="line">    out.println(arr.stream().anyMatch(i -&gt; i &gt; <span class="number">6</span>));</span><br><span class="line">    out.println(arr.stream().noneMatch(i -&gt; i &lt; <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    Optional&lt;Integer&gt; any = arr.stream().filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).findAny();</span><br><span class="line">    out.println(any.get());</span><br><span class="line"></span><br><span class="line">    Optional&lt;Integer&gt; first = arr.stream().filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).findFirst();</span><br><span class="line">    first.ifPresent(out::println);</span><br><span class="line">    out.println(first.get()); <span class="comment">//没有就抛出 NoSuchElementException</span></span><br><span class="line">    out.println(first.orElse(-<span class="number">1</span>)); <span class="comment">// 如果first为空就输出-1</span></span><br><span class="line"></span><br><span class="line">    System.out.println(first.filter(i -&gt; i == <span class="number">2</span>).get()); <span class="comment">// Optional还会产生一个stream</span></span><br><span class="line">    System.out.println(find(arr, -<span class="number">1</span>, i -&gt; i &gt; <span class="number">10</span>)); <span class="comment">// 自己写的一个防止空指针的，而Optional中有一个已经存在的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(List&lt;Integer&gt; values, <span class="keyword">int</span> defaultValue, Predicate&lt;Integer&gt; predicate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> val : values)&#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(val))</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reduceTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    System.out.println(arr.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b)); <span class="comment">//计算数组的和 ,有初始值就是Integer</span></span><br><span class="line">    arr.stream().reduce((a, b) -&gt; a + b).ifPresent(out::println); <span class="comment">// 没有初始值就是 Optional</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取所有的偶数相乘</span></span><br><span class="line">    <span class="keyword">int</span> res = arr.stream().filter(x -&gt; x%<span class="number">2</span> == <span class="number">0</span>).reduce(<span class="number">1</span>, (a, b) -&gt; a*b);</span><br><span class="line">    Optional.of(res).ifPresent(out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、串行流与并行流"><a href="#四、串行流与并行流" class="headerlink" title="四、串行流与并行流"></a>四、串行流与并行流</h3><blockquote>
<p>Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p>
</blockquote>
<p>使用：就是将 <code>stream()</code> 改为<code>parallelStream()</code>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8-Lambda表达式</title>
    <url>/2020/05/22/Java8--Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="一、Lambda基础语法"><a href="#一、Lambda基础语法" class="headerlink" title="一、Lambda基础语法"></a>一、Lambda基础语法</h3><p>1）<code>-&gt;</code>：箭头表达式</p>
<ul>
<li><p>箭头左边：参数列表   ，无参使用() </p>
</li>
<li><p>箭头右边：实现接口中抽象方法的实现代码</p>
</li>
</ul>
<p>2）只有一个参数的话，可以省略参数的括号实现</p>
<p>3）只有一条语句的话，可以省略大括号，也可省略<code>return</code>关键字</p>
<a id="more"></a>

<h3 id="二、Lambda的实质"><a href="#二、Lambda的实质" class="headerlink" title="二、Lambda的实质"></a>二、Lambda的实质</h3><p>对接口的唯一抽象方法的实现</p>
<h3 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h3><p>先举个例子：</p>
<p>未使用Lambda:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"go to school"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       t1.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>使用Lambda</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Go to school"</span>)).start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、四大函数式接口"><a href="#四、四大函数式接口" class="headerlink" title="四、四大函数式接口"></a>四、四大函数式接口</h3><h4 id="1）消费者接口"><a href="#1）消费者接口" class="headerlink" title="1）消费者接口"></a>1）消费者接口</h4><blockquote>
<p>无返回值，对传入的参数操作即可</p>
</blockquote>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   	<span class="comment">// 接收一个泛型T</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：接收一个字符串并打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.8 提供的消费者的接口</span></span><br><span class="line">        Consumer&lt;String&gt; con = x -&gt; System.out.println(<span class="string">"accept: "</span>+x);</span><br><span class="line">        con.accept(<span class="string">"Tom"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 输出：accept Tom</span></span><br></pre></td></tr></table></figure>

<h4 id="2）供应者接口"><a href="#2）供应者接口" class="headerlink" title="2）供应者接口"></a>2）供应者接口</h4><blockquote>
<p>返回一个T类型</p>
</blockquote>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 返回给定的泛型参数类型</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：生成一个随机数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// 只有一句，return可以省略</span></span><br><span class="line">      Supplier&lt;Integer&gt; sup = () -&gt; Integer.valueOf(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">      Integer val = sup.get();</span><br><span class="line">      System.out.println(val);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）判断式接口"><a href="#3）判断式接口" class="headerlink" title="3）判断式接口"></a>3）判断式接口</h4><blockquote>
<p>对传入的泛型参数做boolean判断</p>
</blockquote>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//判断</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String str = <span class="string">"hell"</span>;</span><br><span class="line">       <span class="keyword">boolean</span> bool = isEmpty(str, s -&gt; s.isEmpty());</span><br><span class="line">       System.out.println(bool);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(String str, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pre.test(str);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4）函数式接口"><a href="#4）函数式接口" class="headerlink" title="4）函数式接口"></a>4）函数式接口</h4><blockquote>
<p>接收一个泛型T,返回一个泛型R</p>
</blockquote>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   	 * 根据t，返回一个R类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例：通过一个名字创建一个用户</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                    <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User tom = createUser(<span class="string">"Tom"</span>, name -&gt; <span class="keyword">new</span> User(name));</span><br><span class="line">        System.out.println(tom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">createUser</span><span class="params">(String name, Function&lt;String,User&gt; fun)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fun.apply(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User&#123;name=<span class="string">'Tom'</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、方法引用"><a href="#五、方法引用" class="headerlink" title="五、方法引用"></a>五、方法引用</h3><blockquote>
<p>下表引用自：<a> <a href="https://www.cnblogs.com/wuhenzhidu/p/10727065.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuhenzhidu/p/10727065.html</a> 侵删</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>语法</th>
<th>对应的Lambda表达式</th>
</tr>
</thead>
<tbody><tr>
<td>静态方法引用</td>
<td>类名::staticMethod</td>
<td>(args) -&gt; 类名.staticMethod(args)</td>
</tr>
<tr>
<td>实例方法引用</td>
<td>inst::instMethod</td>
<td>(args) -&gt; inst.instMethod(args)</td>
</tr>
<tr>
<td>对象方法引用</td>
<td>类名::instMethod</td>
<td>(inst,args) -&gt; 类名.instMethod(args)</td>
</tr>
<tr>
<td>构建方法引用</td>
<td>类名::new</td>
<td>(args) -&gt; new 类名(args)</td>
</tr>
</tbody></table>
<h4 id="1）静态方法引用"><a href="#1）静态方法引用" class="headerlink" title="1）静态方法引用"></a>1）静态方法引用</h4><blockquote>
<p>抽象方法的参数列表要和调用的静态方法的参数一致</p>
<p>格式：类名::静态方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">    <span class="comment">//简写</span></span><br><span class="line">    Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）实例方法引用"><a href="#2）实例方法引用" class="headerlink" title="2）实例方法引用"></a>2）实例方法引用</h4><blockquote>
<p>抽象方法的参数要和实例方法参数一致</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Consumer&lt;String&gt; consumer = x-&gt; System.out.println(x);</span><br><span class="line">       <span class="comment">//简写</span></span><br><span class="line">       consumer = System.out::println;</span><br><span class="line"></span><br><span class="line">       consumer.accept(<span class="string">"Hello"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）对象方法引用"><a href="#3）对象方法引用" class="headerlink" title="3）对象方法引用"></a>3）对象方法引用</h4><blockquote>
<p>Lambda参数列表中的第一个参数是实例方法的调用者、第二个是实例方法参数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y);</span><br><span class="line">    BiPredicate&lt;String, String&gt; bp2 = String::equals;</span><br><span class="line">    <span class="comment">//Lambda参数列表中的第一个参数x,是实例方法的第一个调用者x。</span></span><br><span class="line">    <span class="comment">//第二个参数y是实例方法的参数y。则可以使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4）构造方法引用"><a href="#4）构造方法引用" class="headerlink" title="4）构造方法引用"></a>4）构造方法引用</h4><blockquote>
<p>构造器的参数列表和抽象方法列表一致</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Supplier&lt;User&gt; supplier1 = ()-&gt; <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">      Supplier&lt;User&gt; supplier2 = User::<span class="keyword">new</span>;</span><br><span class="line">      User user = supplier.get();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java8新特性</tag>
      </tags>
  </entry>
</search>
